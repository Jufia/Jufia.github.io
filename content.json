[{"title":"找错误积累","date":"2024-02-29T12:44:53.000Z","path":"2024/02/29/与pip和canda的爱恨情仇/","text":"¶摘要 在写hexo，学习CS61A，机器学习、深度学习的过程中逐渐摸清了python、pip、anaconda、npm等之间的关系，这里记录一些我们之间的“爱恨情仇”，主要是出现问题和解决问题的过程。 ¶‘[SSL: UNEXPECTED_EOF_WHILE_READING] EOF occurred in violation of protocol (_ssl.c:1000)’))’ 背景：在实验室用pip下载tensorflow的时候报的错，乍一看是代理的问题，但把代理关掉后依然报错后我开始反思。当时的电脑环境的确变化比较大，给python升了个级，安装了anaconda，(因为太菜不知道什么原因)原来下载过的包也没了，一时慌乱神，上网也没有达到解答，于是求助了本科的大佬。 大佬提示是hit镜像源不稳定的原因，让我换成清华源，这才注意到hit镜像源，我不记得我有配过这个镜像源，可能是本科做大创时队友弄的。 博客园-pip和conda添加和删除镜像源 换成清华源后发现下载速度还不如不用镜像快，就也删掉了，参考文献先留着，万一以后hit源又支楞起来了呢。","categories":[{"name":"高效工作","slug":"高效工作","permalink":"http://example.com/categories/%E9%AB%98%E6%95%88%E5%B7%A5%E4%BD%9C/"},{"name":"Hexo","slug":"高效工作/Hexo","permalink":"http://example.com/categories/%E9%AB%98%E6%95%88%E5%B7%A5%E4%BD%9C/Hexo/"}],"tags":[{"name":"work","slug":"work","permalink":"http://example.com/tags/work/"}]},{"title":"python05-功能与调试","date":"2023-12-05T06:34:15.000Z","path":"2023/12/05/python05-功能与调试/","text":"check and Test How to use assert How to tast .py program Print Debugging Interactive Debugging (交互式调试) Error types in Python How to read Tracebacks try statement ¶Try Statements Try statements handle exceptions 12345try: &lt;try suite&gt;except &lt;exception class&gt; as &lt;name&gt;: &lt;except suite&gt;... Execution rule: The &lt;try suite&gt; is executed first. If， during the course of executing the &lt;try suite&gt;, an exception is raised that is not handled otherwise, and If the class of the exception inherits from &lt;exception class&gt;, then The &lt;except suite&gt; is executed, with &lt;name&gt; bound to the exception. 123456789101112131415161718def invert(x): y = 1/x print('Never printed if x is 0') return ydef invert_safe(x): try: return invert(x) except ZeroDivisionError as e: print('handle', e) return 0&gt;&gt;&gt; &gt;&gt;&gt; invert_safe(1) Never printed if x is 01.0&gt;&gt;&gt; invert_safe(0) handle division by zero0 ¶assert Using assert will make error detection easeier, for example: 1234567891011121314151617181920def fac(x): assert isinstance(x, int) assert x &gt;= 0 if x == 0: return 1 else: return x*fac(x-1)def half_fact(x): return fac(x/2)&gt;&gt;&gt; half_fact(5)Traceback (most recent call last): File \"&lt;stdin&gt;\", line 1, in &lt;module&gt; File \"E:\\document\\U\\language\\python\\main.py\", line 11, in half_fact return fac(x/2) File \"E:\\document\\U\\language\\python\\main.py\", line 3, in fac assert isinstance(x, int)AssertionError If no assert statement, we will get massgaes RecursionError: maximum recursion depth exceeded in comparison. ¶Testing The advantages of Testing: Detect errors in your code Have confidence in the correctness of subcomponents Narrow down the scope of debugging Document how your code works Python provides a way to write tests as part of the docstring: 123456789# in file.pydef fib(n): \"\"\"Fibonacci &gt;&gt;&gt; fib(2) 1 &gt;&gt;&gt; fib(10) 55 \"\"\"... Just run python -m doctest file.py, if everything is ok, there will be nothing to show. It is worthy holding as brief as possible. ¶Print Debugging Compared to two above mathod for program checking, print debugging is more simple and easer, it will gives you an insight into what is going on quickly. ¶Interactive Debugging You can step through your code line by line on PythonTutor, Just copy your code into tutor.cs61a.org. ¶Error Types SyntaxError The file you ran isn’t valid python syntax. (您运行的文件不是有效的 python 语法) Extra or missing parentheses (多余或缺失的括号) Missing colon at the end of an if or while statement (if 或 while 语句末尾缺少冒号) You started writing a statement but forgot to put anything inside (您开始写一个表达式，却忘了在里面写什么) IndentationError The file you ran isn’t valid python syntax, because of indentation inconsistency (您运行的文件不是有效的 python 语法，因为缩进不一致) You made a typo and misaligned something (你打错字了，有些地方对不上号) You accidentally mixed tabs and spaces (您不小心混用了制表符和空格) You used the wrong kind of spaces (你用错了空格) TypeError: … ‘X’ object is not callable … Objects of type X cannot be treated as functions (X 类型的对象不能被视为函数) Variables that should be functions being assigned to non-functions (本应属于函数的变量被分配给非函数) Local variables that do not contain functions having the same name as functions in the global frame (不包含与全局框架中函数同名的函数的局部变量) TypeError: … NoneType … You used None in some operation it wasn’t meant for (您在某些操作中使用了 “None”，而它并不是用来执行这些操作的) check Functions missing return statements (缺少返回语句的函数) NameError or UnboundLocalError Python looked up a name but didn’t find it, it practically means you made a typo ¶Tracebacks","categories":[{"name":"Language","slug":"Language","permalink":"http://example.com/categories/Language/"},{"name":"python","slug":"Language/python","permalink":"http://example.com/categories/Language/python/"}],"tags":[{"name":"Language","slug":"Language","permalink":"http://example.com/tags/Language/"}]},{"title":"python04-树列表和序列","date":"2023-09-10T02:25:33.000Z","path":"2023/09/10/python04-树列表和序列/","text":"Lists are Python data structures that can store multiple values. Each value can be any type and can even be another list! lists bound and index Concatenation and repetition Nested lists Processing Container Values gititem() length() sum() max() all() Lists in contol flows Whether an element in a List How to check if a list is empty in Python trees range strings dictionaries ¶Lists ¶bound and index Use [] to bound a list argument and use [] to index. eg: 12345&gt;&gt;&gt; odds = [41, 43, 47, 49]&gt;&gt;&gt; odds[0]41&gt;&gt;&gt; odds[1]43 The number of a list is begin with number 0, which differ with MTLAB beinging with number 1. The way to find an element is same with how lists are bound, that is [], while the way to find elements is using () in MATLAB. 12345678910111213&gt;&gt;&gt; list(range(1, 3))[1, 2]&gt;&gt;&gt; odds = [3, 5, 7, 9, 11]&gt;&gt;&gt; [odds[i] for i in range(1, 3)][5, 7]&gt;&gt;&gt; odds[1:3][5, 7]&gt;&gt;&gt; odds[:3][3, 5, 7]&gt;&gt;&gt; odds[1:][5, 7, 9, 11]&gt;&gt;&gt; odds[:][3, 5, 7, 9, 11] Similar to Matlab, “:” save as the mean of “all” in a list. In Python, any lists are orderd with the begining of “0”, LISTname[m:n] means the elements form LISTname[m] to LISTname[n-1], totaly (n-m) elments. ¶Concatenation and repetition In Lists, the operator * means repetition and + stands for concatenation. 123&gt;&gt;&gt; digits = [1, 8, 2, 8]&gt;&gt;&gt; [2, 7] + digits *2[2, 7, 1, 8, 2, 8, 1, 8, 2, 8] We could also use the add() and mul() functions 12&gt;&gt;&gt; add([2, 7], mul(digits, 2))[2, 7, 1, 8, 2, 8, 1, 8, 2, 8] ¶Nested lists 嵌套的列表 The elements of Lists could be anything including other lists. 12345&gt;&gt;&gt; pairs = [[10, 20], [30, 40]]&gt;&gt;&gt; pairs[1][30, 40]&gt;&gt;&gt; pairs[1][0]30 ¶Processing Container Values ¶gititem() This is the other way disugned for selecting elements, usage: 12&gt;&gt;&gt; getitem(odds, 0)41 ¶length of lists Use function len(lstName) to calculate how long a list argument is. eg: 12&gt;&gt;&gt; len(odds)4 ¶sum() sum(iterable[, start]) -&gt; value Return the sum of an iterable of numbers (NOT strings) plus the value of parameter ‘start’ (which defaults to 0). When the iterable is empty, return start. ¶max() max(iterable[, key=func]) -&gt; value max(a, b, c, ...[, key=func]) -&gt; value With a single iterable argument, return its largest item. With two or more arguments, return the largest argument. 123456789101112&gt;&gt;&gt; bool('hello')True&gt;&gt;&gt; bool('')False&gt;&gt;&gt; range(5)range(0, 5)&gt;&gt;&gt; [x &lt; 5 for x in range(5)][True, True, True, True, True]&gt;&gt;&gt; all([x &lt; 5 for x in range(5)])True&gt;&gt;&gt; all(range(5))False ¶all() all(iterable) -&gt; bool Return True if bool(x) is True for all values x in the iterable. If the iterable is empty, return True. ¶Lists in contol flows s is a name of one list and requirement of for cycles would be 12&gt;&gt;&gt; for elements in S:... &lt;statements&gt; For that usage, elements will be bound to the value in the current frame and then execute the . 12345678910&gt;&gt;&gt; pairs = [[1, 2], [3, 3], [3, 5], [2, 2]]&gt;&gt;&gt; pairs[[1, 2], [3, 3], [3, 5], [2, 2]]&gt;&gt;&gt; for x, y in pairs:... print(x, y)...1 23 332 2 ¶List Comprehensions List comprehensions are a compact and powerful way of creating new lists out of sequences. The general syntax for a list comprehension is the following: 1[&lt;expression&gt; for &lt;element&gt; in &lt;sequence&gt; if &lt;conditional&gt;] The syntax is designed to read like English: “Compute the expression for each element in the sequence if the conditional is true for that element.” 12345678910&gt;&gt;&gt; [i**2 for i in [1, 2, 3, 4] if i % 2 == 0][4, 16]# is equal to the follow statement:&gt;&gt;&gt; lst = []&gt;&gt;&gt; for i in [1, 2, 3, 4]:... if i % 2 == 0:... lst = lst + [i**2]&gt;&gt;&gt; lst[4, 16] This is a brilliant example: 123456789101112def riffle(deck): \"\"\"Produces a single, perfect riffle shuffle of DECK, consisting of DECK[0], DECK[M], DECK[1], DECK[M+1], ... where M is position of the second half of the deck. Assume that len(DECK) is even. &gt;&gt;&gt; riffle([3, 4, 5, 6]) [3, 5, 4, 6] &gt;&gt;&gt; riffle(range(20)) [0, 10, 1, 11, 2, 12, 3, 13, 4, 14, 5, 15, 6, 16, 7, 17, 8, 18, 9, 19] \"\"\" \"*** YOUR CODE HERE ***\" M = len(deck) // 2 return [deck[k//2 + M*(k % 2)] for k in range(len(deck))] ¶Whether an element in a List Use operator in and not in for judgement. 12345678910111213&gt;&gt;&gt; 1 in digitsTrue&gt;&gt;&gt; 5 in digitsFalse&gt;&gt;&gt; 5 not in digitsTrue&gt;&gt;&gt; [1, 8] in digitsFalse&gt;&gt;&gt; [1, 2] in [3, [1, 2], 4]True&gt;&gt;&gt; [1, 2] in [3, [[1, 2]], 4]False ¶How to check if a list is empty in Python 123456789# Since an empty list is Falsenot empty # or lst = []if ist: print('not empty')# Another common method is with the Implication of a notif not lst: print('empty') reference: How to check if a list is empty in Python? ¶range range is pressent a sesquence that consist of int. For exemple: range(n) is means the numbers from 0 to n but not include n. Function range usually using in “for” loop. 123456789101112131415&gt;&gt;&gt; for i in range(4):... print(i)...0123&gt;&gt;&gt; for _ in range(3):... print('Go Jufia!')...Go Jufia!Go Jufia!Go Jufia! There is difference between Python and C, for C language must use index when reserch lest while Python could seperate elements directly. Usage of range about list: 12345&gt;&gt;&gt; list(range(1, 3))[1, 2]&gt;&gt;&gt; odds = [3, 5, 7, 9, 11]&gt;&gt;&gt; [odds[i] for i in range(1, 3)][5, 7] ¶Trees A tree has a root and a list of branches. Each branch is a tree. A tree with zero branches is called a leaf. Each location in a tree is called a node. Each node has a label value. One node can be the parent/child of another. Some defination and usage: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889# Tree ADTdef tree(label, branches=[]): \"\"\"Construct a tree with the given label value and a list of branches.\"\"\" if change_abstraction.changed: for branch in branches: assert is_tree(branch), 'branches must be trees' return {'label': label, 'branches': list(branches)} else: for branch in branches: assert is_tree(branch), 'branches must be trees' return [label] + list(branches)def label(tree): \"\"\"Return the label value of a tree.\"\"\" if change_abstraction.changed: return tree['label'] else: return tree[0]def branches(tree): \"\"\"Return the list of branches of the given tree.\"\"\" if change_abstraction.changed: return tree['branches'] else: return tree[1:]def is_tree(tree): \"\"\"Returns True if the given tree is a tree, and False otherwise.\"\"\" if change_abstraction.changed: if type(tree) != dict or len(tree) != 2: return False for branch in branches(tree): if not is_tree(branch): return False return True else: if type(tree) != list or len(tree) &lt; 1: return False for branch in branches(tree): if not is_tree(branch): return False return Truedef is_leaf(tree): \"\"\"Returns True if the given tree's list of branches is empty, and False otherwise. \"\"\" return not branches(tree)def change_abstraction(change): change_abstraction.changed = changechange_abstraction.changed = Falsedef print_tree(t, indent=0): \"\"\"Print a representation of this tree in which each node is indented by two spaces times its depth from the root. &gt;&gt;&gt; print_tree(tree(1)) 1 &gt;&gt;&gt; print_tree(tree(1, [tree(2)])) 1 2 &gt;&gt;&gt; numbers = tree(1, [tree(2), tree(3, [tree(4), tree(5)]), tree(6, [tree(7)])]) &gt;&gt;&gt; print_tree(numbers) 1 2 3 4 5 6 7 \"\"\" print(' ' * indent + str(label(t))) for b in branches(t): print_tree(b, indent + 1)def copy_tree(t): \"\"\"Returns a copy of t. Only for testing purposes. &gt;&gt;&gt; t = tree(5) &gt;&gt;&gt; copy = copy_tree(t) &gt;&gt;&gt; t = tree(6) &gt;&gt;&gt; print_tree(copy) 5 \"\"\" return tree(label(t), [copy_tree(b) for b in branches(t)]) ¶Strings Strings are exectly a type of sesquence. Strings can be regard as a list consisting with every charactrastic: ‘Jufia’ can be considered as [‘J’, ‘u’, ‘f’, ‘i’, ‘a’]. 123&gt;&gt;&gt; city = 'Jufia'&gt;&gt;&gt; city[1]'u' An element of s string is itslef a string, but with only one element. ¶dictionaries Dictionalr is consisted by patrs of key and value. Being selected by key wlii get the number. 12345678910111213141516171819202122&gt;&gt;&gt; {'i':1, 'v':5, 'x': 10}{'i': 1, 'v': 5, 'x': 10}&gt;&gt;&gt; numerals = {'i':1, 'v':5, 'x': 10}&gt;&gt;&gt; numerals['x']10 &gt;&gt;&gt; numerals[10]Traceback (most recent call last): File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;KeyError: 10&gt;&gt;&gt; numerals{'i': 1, 'v': 5, 'x': 10}&gt;&gt;&gt; numerals.keys()dict_keys(['i', 'v', 'x'])&gt;&gt;&gt; numerals.values()dict_values([1, 5, 10])&gt;&gt;&gt; numerals.items()dict_items([('i', 1), ('v', 5), ('x', 10)])&gt;&gt;&gt; items =[('i', 1), ('v', 5), ('x', 10)]&gt;&gt;&gt; dict(items){'i': 1, 'v': 5, 'x': 10}&gt;&gt;&gt; dict(items)['x']10","categories":[{"name":"Language","slug":"Language","permalink":"http://example.com/categories/Language/"},{"name":"python","slug":"Language/python","permalink":"http://example.com/categories/Language/python/"}],"tags":[{"name":"Language","slug":"Language","permalink":"http://example.com/tags/Language/"}]},{"title":"pythono03-高阶函数与递归","date":"2023-09-10T02:24:56.000Z","path":"2023/09/10/python03-高阶函数与递归/","text":"Before talking about Control Fllows and Higher-Order Functions, we should have cleared how Functions form and the relatioinship about Functions and lambda expressions. 使用迭代递归可以减少赋值语句，使代码的可移植性更强. Control Fllows ¶Introduction 迭代(iteratively)：利用已知的变量值，不断用变量的旧值递推新值，直到到达结束状态。 递归(recursively)：函数直接或间接调用函数自身，直到满足终止条件，再逐层回归。 例如： 1234567891011121314151617181920212223242526272829def reverse_iter(lst): \"\"\"Returns the reverse of the given list. &gt;&gt;&gt; reverse_iter([1, 2, 3, 4]) [4, 3, 2, 1] &gt;&gt;&gt; import inspect, re &gt;&gt;&gt; cleaned = re.sub(r\"#.*\\\\n\", '', re.sub(r'\"{3}[\\s\\S]*?\"{3}', '', inspect.getsource(reverse_iter))) &gt;&gt;&gt; print(\"Do not use lst[::-1], lst.reverse(), or reversed(lst)!\") if any([r in cleaned for r in [\"[::\", \".reverse\", \"reversed\"]]) else None \"\"\" \"*** YOUR CODE HERE ***\" tem = [] for i in lst: tem = [i] + tem return temreverse_iter([1, 2, 3, 4])def reverse_recursive(lst): \"\"\"Returns the reverse of the given list. &gt;&gt;&gt; reverse_recursive([1, 2, 3, 4]) [4, 3, 2, 1] &gt;&gt;&gt; import inspect, re &gt;&gt;&gt; cleaned = re.sub(r\"#.*\\\\n\", '', re.sub(r'\"{3}[\\s\\S]*?\"{3}', '', inspect.getsource(reverse_recursive))) &gt;&gt;&gt; print(\"Do not use lst[::-1], lst.reverse(), or reversed(lst)!\") if any([r in cleaned for r in [\"[::\", \".reverse\", \"reversed\"]]) else None \"\"\" \"*** YOUR CODE HERE ***\" if not lst: return lst return [lst[-1]] + reverse_recursive(lst[:-1]) ¶Functions Functions consists of Name, Statements, Input and Return. The input would be any type such as functions, figure, string… When a functiuon’s input is vary itself, is forms an iteration and this function is one of the Hight-Order Function. These are some examples: 12345678def fib(n): \"\"\"Compute the nth Fibonacci number, for N &gt;= 1.\"\"\" pred, curr = 0, 1 # 0th and 1st Fibonacci numbers k = 1 # curr is the kth Fibonacci number while k &lt; n: pred, curr = curr, pred + curr k = k + 1 return curr ¶lambda Lambda like Function, it could present an expression with one or more input Values and return the answer of those inputs. 123456789101112131415161718192021&gt;&gt;&gt; lambda x: x*x # A lambda expression with one parameter x&lt;function &lt;lambda&gt; at 0x0000020FEC7EE310&gt;&gt;&gt;&gt; a = lambda x: x*x # Assigning the lambda function to the name a&gt;&gt;&gt; a(5)25&gt;&gt;&gt; (lambda: 3)() # Using a lambda expression as an operator in a call exp.3&gt;&gt;&gt; b = lambda x: lambda: x # Lambdas can return other lambdas!&gt;&gt;&gt; c = b(88)&gt;&gt;&gt; c&lt;function &lt;lambda&gt;.&lt;locals&gt;.&lt;lambda&gt; at 0x0000020FEC7EE040&gt;&gt;&gt;&gt; c()88&gt;&gt;&gt; z = 3&gt;&gt;&gt; e = lambda x: lambda y: lambda: x + y + z&gt;&gt;&gt; e(0)(1)()4 ¶Control Fllows ¶Operators Boolean Operators True False Comparison Operators ==: The “equal to” operator. !=: The “not equal to” operator. &lt;: The “less than” operator. &gt;: The “greater than” operator. &lt;=: The “less than or equal to” operator. &gt;=: The “greater than or equal to” operator. Logical Operators and &amp; or | not ~ ^ : Bitwise xor, . It evaluates to True if exactly one of the two bits is True. Evaluation rule for “and” “or” To evaluate the expression &lt;left&gt; and &lt;right&gt;: Evaluate the subexpression &lt;left&gt;. If the result is a false value v, then the expression evaluates to v. Otherwise, the expression evaluates to the value of the subexpression &lt;right&gt;. To evaluate the expression &lt;left&gt; or &lt;right&gt;: Evaluate the subexpression &lt;left&gt;. If the result is a true value v, then the expression evaluates to v. Otherwise, the expression evaluates to the value of the subexpression &lt;right&gt;. It is the same sa C. ¶Control Operator if / elif / else while for ¶Conditional Expressions A conditional expression has the form: &lt;consequent&gt; if &lt;predicate&gt; else &lt;alternative&gt;. Evaluation rule: Evaluate the &lt;predicate&gt; expression. If it’s a true value, the value of the whole expression is the value of the &lt;consequent&gt;. Otherwise, the value of the whole expression is the value of the &lt;alternative&gt;. ¶Higher-Order Functions When functions as Return Values, ther are named Higher-Order Functions. ¶Recursion 递归 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596from operator import add, mul, subsquare = lambda x: x * xidentity = lambda x: xtriple = lambda x: 3 * xincrement = lambda x: x + 1def product(n, term): \"\"\"Return the product of the first n terms in a sequence. n -- a positive integer term -- a function that takes one argument to produce the term &gt;&gt;&gt; product(3, identity) # 1 * 2 * 3 6 &gt;&gt;&gt; product(5, identity) # 1 * 2 * 3 * 4 * 5 120 &gt;&gt;&gt; product(3, square) # 1^2 * 2^2 * 3^2 36 &gt;&gt;&gt; product(5, square) # 1^2 * 2^2 * 3^2 * 4^2 * 5^2 14400 &gt;&gt;&gt; product(3, increment) # (1+1) * (2+1) * (3+1) 24 &gt;&gt;&gt; product(3, triple) # 1*3 * 2*3 * 3*3 162 \"\"\" \"*** YOUR CODE HERE ***\" init = 1 for i in range(1, n + 1): init *= term(i) return initdef accumulate(combiner, base, n, term): \"\"\"Return the result of combining the first n terms in a sequence and base. The terms to be combined are term(1), term(2), ..., term(n). combiner is a two-argument commutative function. &gt;&gt;&gt; accumulate(add, 0, 5, identity) # 0 + 1 + 2 + 3 + 4 + 5 15 &gt;&gt;&gt; accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5 26 &gt;&gt;&gt; accumulate(add, 11, 0, identity) # 11 11 &gt;&gt;&gt; accumulate(add, 11, 3, square) # 11 + 1^2 + 2^2 + 3^2 25 &gt;&gt;&gt; accumulate(mul, 2, 3, square) # 2 * 1^2 * 2^2 * 3^2 72 &gt;&gt;&gt; accumulate(lambda x, y: x + y + 1, 2, 3, square) 19 &gt;&gt;&gt; accumulate(lambda x, y: 2 * (x + y), 2, 3, square) 58 &gt;&gt;&gt; accumulate(lambda x, y: (x + y) % 17, 19, 20, square) 16 \"\"\" \"*** YOUR CODE HERE ***\" acc, i = base, 1 while i &lt;= n: acc, i = combiner(acc, term(i)), i+1 return accdef summation_using_accumulate(n, term): \"\"\"Returns the sum of term(1) + ... + term(n). The implementation uses accumulate. &gt;&gt;&gt; summation_using_accumulate(5, square) 55 &gt;&gt;&gt; summation_using_accumulate(5, triple) 45 &gt;&gt;&gt; from construct_check import check &gt;&gt;&gt; # ban iteration and recursion &gt;&gt;&gt; check(HW_SOURCE_FILE, 'summation_using_accumulate', ... ['Recursion', 'For', 'While']) True \"\"\" \"*** YOUR CODE HERE ***\" return accumulate(add, 0, n, term)def product_using_accumulate(n, term): \"\"\"An implementation of product using accumulate. &gt;&gt;&gt; product_using_accumulate(4, square) 576 &gt;&gt;&gt; product_using_accumulate(6, triple) 524880 &gt;&gt;&gt; from construct_check import check &gt;&gt;&gt; # ban iteration and recursion &gt;&gt;&gt; check(HW_SOURCE_FILE, 'product_using_accumulate', ... ['Recursion', 'For', 'While']) True \"\"\" \"*** YOUR CODE HERE ***\" return accumulate(mul, 1, n, term)","categories":[{"name":"Language","slug":"Language","permalink":"http://example.com/categories/Language/"},{"name":"python","slug":"Language/python","permalink":"http://example.com/categories/Language/python/"}],"tags":[{"name":"Language","slug":"Language","permalink":"http://example.com/tags/Language/"}]},{"title":"python02-输出和返回值","date":"2023-09-10T02:24:08.000Z","path":"2023/09/10/python02-输出和返回值/","text":"In this section, we will make our way to explain these problems: How to name an argument in Python. How to define a user function. What will python display? Print and None. About print display and return value. ¶Variables We name an argument CS61A, and CS61A can be bound to any Value type including Numbers, Functions, Lambdas… It’s worthy to be noticed that one name mast be bound to one and only one value. 12345678910111213&gt;&gt;&gt; from math import pi&gt;&gt;&gt; pi3.141592653589793&gt;&gt;&gt;&gt;&gt;&gt; def TwoTimes(x):... y = 2*x... return y...&gt;&gt;&gt; pi = TwoTimes&gt;&gt;&gt; pi&lt;function TwoTimes at 0x0000023A7B953E20&gt;&gt;&gt;&gt; pi(2)4 We can learn that when pi dosen’t bound, pi presents a number definded in &lt;module&gt; ‘math’ , and pi can become other value such as a Function we have just done. python supports giving values to several variables at one time. 1234567&gt;&gt;&gt; a, b, c = 1, 2, 3&gt;&gt;&gt; a1&gt;&gt;&gt; b2&gt;&gt;&gt; c3 Furthermore, python can split the values in a sequence to multiple variables which can only one by one in MATLAB. 1234567891011121314151617&gt;&gt;&gt; sequence = [1, 2, 3]&gt;&gt;&gt; a, b, c = sequence&gt;&gt;&gt; a1&gt;&gt;&gt; b2&gt;&gt;&gt; c3&gt;&gt;&gt;&gt;&gt;&gt; sequence = [1, 2, 'str', [3, 4]]&gt;&gt;&gt; for k in sequence:... print(k)...12str[3, 4] It’s clear that elements in a sequence are NOT required to be same type. ¶What will Python display ¶Functions Defindining functions 12&gt;&gt;&gt; def &lt;name&gt;(&lt;formal parameters&gt;):... return &lt;reture expresstion&gt; ¶None None dosen’t mean the string ‘None’, not even a number, it is a special value indicating Nothing in Python. 1234567891011&gt;&gt;&gt; x = None&gt;&gt;&gt; x&gt;&gt;&gt; y = 'None'&gt;&gt;&gt; y'None'&gt;&gt;&gt; x + 4Traceback (most recent call last): File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;TypeError: unsupported operand type(s) for +: 'NoneType' and 'int'&gt;&gt;&gt; y + '123''None123' ¶print and return A return statement completes the evaluation of a call expression and provides its value. The returned statement can be a very value, an equation and a function with parameters. If a function has nothing to return, it returns None, Such as print.Look at this: 1234&gt;&gt;&gt; print(print(1), print(2))12None None If the argument to print is a constant, the value of constant will be display directly, if it is a function the output would depends on what return is. Notice: print ends in ‘/n’ by default.","categories":[{"name":"Language","slug":"Language","permalink":"http://example.com/categories/Language/"},{"name":"python","slug":"Language/python","permalink":"http://example.com/categories/Language/python/"}],"tags":[{"name":"Language","slug":"Language","permalink":"http://example.com/tags/Language/"}]},{"title":"python01-Introductory","date":"2023-09-07T02:07:54.000Z","path":"2023/09/07/python01-Introductory/","text":"¶摘要 已弃坑北理工 MOOC ，改学伯克利的python课程 CS61A, 信息来源为CS自学指南，课程资料和视频均在文档内，该系列blog依托于CS61A的课程内容整理而来。 CS61A不仅仅在讲编程，还有在教学计算机科学，培养计算机素养，是一门广受好评的课程。 ¶写在前面：通过控制台交互的语句 使用python语言 1python 运行文件 1python -i name.py name.py文件里可能有多个函数，调用其中某个函数function 1result = function(arguments) 退出python 123exit()quit()^Z 在python中，可以检验函数。在用一对三双引号框起的部分里，编译python时会检查 &gt;&gt;&gt; 后的语句，以及输出的值是否与设定一致。例如： 12345678910111213141516171819def product(n, term): \"\"\"Return the product of the first n terms in a sequence. n -- a positive integer term -- a function that takes one argument to produce the term &gt;&gt;&gt; product(3, identity) # 1 * 2 * 3 6 &gt;&gt;&gt; product(5, identity) # 1 * 2 * 3 * 4 * 5 120 &gt;&gt;&gt; product(3, square) # 1^2 * 2^2 * 3^2 36 &gt;&gt;&gt; product(5, square) # 1^2 * 2^2 * 3^2 * 4^2 * 5^2 14400 &gt;&gt;&gt; product(3, increment) # (1+1) * (2+1) * (3+1) 24 &gt;&gt;&gt; product(3, triple) # 1*3 * 2*3 * 3*3 162 \"\"\" \"*** YOUR CODE HERE ***\" 检验函数在控制台里的操作: 先用python -i进入对python文件的编译，再输入 1python3 -m doctest","categories":[{"name":"Language","slug":"Language","permalink":"http://example.com/categories/Language/"},{"name":"python","slug":"Language/python","permalink":"http://example.com/categories/Language/python/"}],"tags":[{"name":"Language","slug":"Language","permalink":"http://example.com/tags/Language/"}]},{"title":"Windows 下 openp2p 内网穿透计划","date":"2023-08-07T09:24:41.000Z","path":"2023/08/07/Windows-下-openp2p-内网穿透计划/","text":"使用 FPR 进行内网穿透需要一台具有公网 IP 的机器且操作复杂，经过一段时间的学习最终被宣告计划破产。现在由网友建议转向基于 openp2p 开展内网穿透计划，操作简单，对设备要求低。 ¶OpenP2P是什么 OpenP2P是一个开源、免费、轻量级的P2P共享网络，可以实现不同局域网下的远程办公。 Openp2pGitHub项目仓库 OpenP2P中文文档 ¶安装教程 bilibili-【openp2p】远程办公、远程4K流媒体、私有云【好用的内网穿透工具】 bilibili-[openp2p] 开源的免费不限速不用购买服务器的内网穿透，Nas和群辉有福了 非常简单，按照文档说的做就好了。 安装完成后会出现一个弹窗： 上面有一些信息，只需要注意这两条：‘文件地址：C:\\Program Files\\OpenP2P’ 和 ‘Visit WebUI on https://console.openp2p.cn’ 先前往应用程序地址处C:\\Program Files\\OpenP2P运行openp2p.exe，然后打开网址，进入到“新建P2P应用”步骤。 此时的“控制计算机”和“被控计算机”都会显示在线，去到“控制计算机”的窗台，点击“P2P应用”添加实例 总是显示连接超时，设置被连接设备“office”开机自启，连接设备“home”使用客户端，不用干涉，耐心等待连接即可。 也可以选择手动运作。 下一步计划：写脚本启动客户端，脱离控制台。","categories":[{"name":"高效工作","slug":"高效工作","permalink":"http://example.com/categories/%E9%AB%98%E6%95%88%E5%B7%A5%E4%BD%9C/"}],"tags":[{"name":"work","slug":"work","permalink":"http://example.com/tags/work/"},{"name":"Frp","slug":"Frp","permalink":"http://example.com/tags/Frp/"},{"name":"云服务器","slug":"云服务器","permalink":"http://example.com/tags/%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8/"}]},{"title":"学术写作之写作技巧","date":"2023-05-01T12:54:33.000Z","path":"2023/05/01/学术写作之写作技巧/","text":"31568d710e28da3e9920134e13d5e8646d9d9a6d4f053e2bb80501ef4445d3b286ebd557059ca08f0960d952ccec24a1e69bf00bf0188eb85d063b70bbcada793317bac88ff2d011478f5f5badede3e511e2e562f4006e76fae78cc054cc2ed77d9f7b14b281710e47d60ac59d3c58402dd557311f326b6fa636424cf5efe19c3e468c8b5cb9d87b918964bb375c618c33b43cf2a1a494cb0956eaa4aea1abfda2cfa886176b7a6a26d1a864613a23e456b26c854f1a1fb648b9f987550b00a99d142c2c9ed5797aef0d280e17a68a79e8f7ee5bd0cc38fceb5bf8c5a329913e62abd7d07b86578151888e000d6b7aae77efba873acbc27c28aab5d3e76915af457444aa4397a12443c8d2f992a60c71450033dec5e8423077f81b6889b086e69ae998a8f78cc3e69a284ed1ba62dd8338a59cbeaa6eb89784f386e08644ee76c363aba84a6a53d284613543ff45775eb31a4591618cd09bc4e52bf6d695c5151e522e6bfaf6b25bda975bdb19e1aa22c117f1de19a8ccfd989e4a82504c2427f264eb2475e202fe38346363cb952665f5456b6ad3eb7ec66910329ad117eb80c181576545f7f8e93a090eecb5d420ef284122c8eee8281533cbb1f67643b741597b37ea2c9033ebf1225883de8868b84fd72f503881dceb9fd2dc10e156331ee34bbb77e6b3bfa694addabb28154128e7e9e5d06448132168697b69c7402f468761892e6f9b5df7429c1079ef26ff8ddc09e59424ec07f902952b3f17c99372901039a252207ffbdd8f32f6a97ef2240693af487fc36705421931232a94566c441784910060304eb06018fa72fa685ea5a5d0f412e4dc136ca0d12f3dacea45226a45a7de8ee9d0c63009599a9468538d8794811dabb336284ec1b6161fc92b13cd848000ef92b3e63fb71007618175913d90ea132e1c08462a253bdd5e1190675beaca63805723bce3da3b37905f69c4d9ff3b9e728aeb526b9ce99cea08b55f19fa7d95f397cb5e3ab221f4acf6f02be29ec80eff2377d435ac21f23b37231047f0091a43e591681b4ec9d3afc54e4449e76d94e9587d319dbac2f1ad3b5ca2188d2ee9196c586aaa64d2f23a5ef43cd24081b62e81781074a976424410ba4107f2675b968010a330536e1832b38e93c05bafdde333a0d3a95a16f609dca42e03982073521341c5a479c84897bd305995f205544dd8acc0accf6fff6e0510e1f571405b84a48cee4816339c6ae8ef0553e9fe85a4bf1d70c23a0ed62a82d4a560531df43c3cb2c21b8a706587db8f901132ec0f2bd44ca5b4d9e030b15f20ac6b5e68496aa689e0ee1f63692d5c183604ad1a9f1f3498cdfb57cf4cff657c14761218de5a4ed026d0086b36cd56b66fd384bc2b382a516fbd8f430394e266a866db10fc030ce7e1b882161370d56da6577f0cd1400e83954e16047ec51f1b49fd7ac48b77ade5d227398109495ddb1e384646453cd9679a6694cc9bd104d1c0785568a0d98dd9df94fa8d2be698199c1b8cdbfea48f4c55aca52bf84e9219b9d84572ca94acc222d166cadf478e8639924c485d5c90d959d2e267c68c2a932e18f27291301d9cb000ddf805ae8b213c61ef50a37d9e83c2e173ded9a499a2 您好, 这里需要密码.","categories":[{"name":"高效工作","slug":"高效工作","permalink":"http://example.com/categories/%E9%AB%98%E6%95%88%E5%B7%A5%E4%BD%9C/"},{"name":"学术写作相关","slug":"高效工作/学术写作相关","permalink":"http://example.com/categories/%E9%AB%98%E6%95%88%E5%B7%A5%E4%BD%9C/%E5%AD%A6%E6%9C%AF%E5%86%99%E4%BD%9C%E7%9B%B8%E5%85%B3/"}],"tags":[{"name":"work","slug":"work","permalink":"http://example.com/tags/work/"},{"name":"学术生产力","slug":"学术生产力","permalink":"http://example.com/tags/%E5%AD%A6%E6%9C%AF%E7%94%9F%E4%BA%A7%E5%8A%9B/"}]},{"title":"Python 代码风格","date":"2023-04-30T08:20:13.000Z","path":"2023/04/30/Python-代码风格/","text":"¶摘要 养成良好的代码习惯，形成良好的代码风格，不仅能够增强代码的可读性，还能够在阅读时少看到一些不美观的波浪线。 以下是根据 Pycham 黄色波浪线整理出的代码规范 ¶命名 函数名应全部使用小写 ¶注释 开头以长篇幅撰写的注释夹在一对\"\"\"符号中 123\"\"\"这里是注释\"\"\" ¶空行 在函数定义 def 语句前需要两行空行 ¶缩进，空格 缩进应该以4个空格为单位 在以逗号作分隔符时，例如数组等，逗号后要跟一个空格。","categories":[{"name":"Language","slug":"Language","permalink":"http://example.com/categories/Language/"},{"name":"python","slug":"Language/python","permalink":"http://example.com/categories/Language/python/"}],"tags":[{"name":"Language","slug":"Language","permalink":"http://example.com/tags/Language/"}]},{"title":"Hexo 学习笔记之渲染","date":"2023-04-25T09:41:47.000Z","path":"2023/04/25/Hexo-学习笔记之渲染/","text":"¶摘要 关于字体、颜色、大小的设置，markdown语法 NexT 主题页面渲染 ¶字体 ¶局部修改字体 可以把 Markdown 看成 HTML 的一个子集，可以在 Markdown 中使用 HTML 语法，Markdown 语法里是没有改变字体、颜色、大小功能的，这个时候就需要借助 HTML 语言 参考文献：Markdown 和 HTML 的区别 12345678&lt;font face=\"黑体\"&gt;我是黑体字&lt;/font&gt; &lt;font face=\"微软雅黑\"&gt;我是微软雅黑&lt;/font&gt;&lt;font face=\"STCAIYUN\"&gt;我是华文彩云&lt;/font&gt;&lt;font color=\"red\"&gt;我是红色&lt;/font&gt;&lt;font color=\"#008000\"&gt;我是绿色&lt;/font&gt;&lt;font color=\"Blue\"&gt;我是蓝色&lt;/font&gt; &lt;font size=\"5\"&gt;我是尺寸&lt;/font&gt;&lt;font face=\"黑体\" color=\"green\" size=\"5\"&gt;我是黑体&amp;#xff0c;绿色&amp;#xff0c;尺寸为5&lt;/font&gt; 我是黑体字 我是微软雅黑 我是华文彩云 我是红色 我是绿色 我是蓝色 我是尺寸 我是黑体，绿色，尺寸为5 参考文献：Markdown进阶（更改字体、颜色、大小，设置文字背景色，调整图片大小设置居中） ¶修改 NexT 主题字体 参考文献： NexT文档 NexT 主题修改中英字体 Google字体页面：https://fonts.google.com/specimen/Merriweather 修改字体前后对比 ¶图片无法显示的问题 图片使用GitHub仓库管理，某一天发现图片无法显示在Hexo 博客上 检查.md文件中的markdown语句，发现GitHub图片改了域名 12原：![image](https://user-images.githubusercontent.com/122464335/234834129-a04ce451-3c6f-4cd4-83e6-74679d9dcfa2.png)后：![image](https://github.com/Jufia/image/assets/122464335/45d9c1a8-b21e-4481-895d-69270505b990) 上网查原因，发现将私有仓库改为共有即可。同时也找到了一个图片管理软件PicGO，原理和GitHub差不多，可以作为一个备选方案。 ¶调节图片大小 设定长宽比例，语法： &lt;img src=\"\" width=\"50%\" height=\"50%\"&gt;，可以让height缺省。 ¶侧边栏添加头像 https://zhuanlan.zhihu.com/p/129644138 ¶网页底部 https://zhuanlan.zhihu.com/p/129644138 ¶网页顶部 在文件\\themes\\next\\layout\\_partials\\head\\head.swig 里语句` `上方添加句子，能够现实在网页最上方，还莫名很好看。","categories":[{"name":"高效工作","slug":"高效工作","permalink":"http://example.com/categories/%E9%AB%98%E6%95%88%E5%B7%A5%E4%BD%9C/"},{"name":"Hexo","slug":"高效工作/Hexo","permalink":"http://example.com/categories/%E9%AB%98%E6%95%88%E5%B7%A5%E4%BD%9C/Hexo/"}],"tags":[{"name":"work","slug":"work","permalink":"http://example.com/tags/work/"}]},{"title":"David Silver 公开课笔记 03 有限马尔可夫决策过程 (MDP)","date":"2023-04-25T08:28:12.000Z","path":"2023/04/25/David-Silver-公开课笔记-03/","text":"¶摘要 由 Reinforcement Learning An Introduction 2 第三章整理而来 有限马尔可夫决策过程 (MDP) 核心性质为：状态与收益的每一个可能值出现的概率只取决于前一个状态和前一个动作，且与更早的状态与动作无关，有限的含义为：状态、动作和收益的集合都只有有限个元素。 ¶智能体与环境 智能体(agent)：进行学习以及实施决策的机器人 环境(environment)：智能体之外所有与其相互作用的事物 question: MDP 框架(figure 3.1) 是否足以有效表示所有目标导向的学习任务？ 不能。关于MDP的主要内容是马尔可夫属性。在有些任务中，这一点并不成立。例如，在扑克中，以前的状态将决定什么在牌中，什么不在。这不符合马尔可夫特性。 ¶目标和收益 收益假设：强化学习所有的“目标”都可以归结为：最大化智能体收到的标量信号（收益）累积和的概率期望。 使用收益信号来形式化目标是强化学习最显著的特征之一。 我们设立收益的方式必须真正表明我们的目标，收益信号只能用来传达什么是我想要实现的目标而不是如何实现这个目标。 例如：国际象棋智能体只有当最后取得胜利时才能后的收益，而并非达到某个子目标，如吃掉对方的子。如果实现这些子目标也能够得到收益，那么智能体可能找到某种避开最终目标也能达到高收益的方式，例如它可能以输掉比赛为代价吃掉对方的子。 ¶回报和收益 幕episodes 或 试验trials：当一个智能体与环境交互式展现出循环的特点时，例如无限次的开始一盘游戏、无限次地走入迷宫……智能体与环境能够被分为一系列子序列，称每一个为幕，每一幕的结束状态称为终结状态。下一幕的开始状态与上一幕的结束方式完全无关。 分幕式任务的回报在最简单的情况下是收益的总和： 其中是最终时刻。 当回报公式(3.7)用于描述持续性任务时会出现汇报趋于无穷的问题，欲解决这个问题，需要引入折扣的概念: 其中: 是折扣率。 递归关系： 特别的，对于收益为0的情况，那么 若，则智能体是目光短浅的，之关心当前的收益最大，一般来说，最大化当前收益会减小未来收益 对于，只要序列有界，则式(3.8)中的无限序列总和就是一个有界值。随着接近1，折扣回报将更多地考虑未来的收益，智能体变得有远见了。 例题： (E3.8)假设，接收到的收益序列是，那么分别是多少？ 2. (E3.9)假设，收益序列是首项的无限 7 循环序列，那么和分别为多少？ ¶策略和价值函数 先区分几个概念： 收益：是在时刻所得到的单个标量数值，具体到取动作时，被表示为。 回报：可以是动作、状态、策略等在一系列动作下得到的累积收益，在分幕式任务中可能只是单纯相加，在持续性任务中引入折扣因子。 价值或者：定义详见本节 价值函数用于评定当前智能体在给定状态或者给定状态与动作下有多好。 策略是从状态到每一个动作的选择概率之间的映射，例如随机策略表示当时的概率。 当前状态是，根据随机策略选择动作，利用和四参数函数(式3.2)来表示的期望。 每一个动作发射的概率每一个动作的收益 策略下的状态的价值函数：从状态开始，智能体按照策略进行决策所得到的回报的概率期望值。称为策略的状态价值函数。 策略在状态时采取动作的价值：从状态开始，智能体按照策略进行决策，执行动作后，所有可能的决策序列的期望回报。称为策略的动作价值函数。","categories":[{"name":"AI","slug":"AI","permalink":"http://example.com/categories/AI/"},{"name":"RL","slug":"AI/RL","permalink":"http://example.com/categories/AI/RL/"}],"tags":[{"name":"AI","slug":"AI","permalink":"http://example.com/tags/AI/"}]},{"title":"David Silver 公开课笔记 02 多臂赌博机问题","date":"2023-04-21T10:20:05.000Z","path":"2023/04/21/David-Silver-公开课笔记-02/","text":"¶摘要 本章与David Silver 公开课课程进度无关 由 Reinforcement Learning An Introduction (Second Edition) 第一章整理而来 强化学习与其他机械学习方法最大的不同，就在于前者的训练信号是用来评估给定动作的好坏，而不是通过给出正确动作范例来进行直接指导。这使得主动的反复试验以试探出更好的动作变得很有必要 ¶K臂赌博机问题 类似于在k个选项中选取一个智能体自认为最好的选择，这个最好可能是智能体已经经过预测后能够得到最大收益的选项，称为贪心方法，也可能是智能体选择了一个可能会带来最大收益的潜力股，称为-贪心方法。 假设每一个动作获得的收益遵从平稳的概率分布，例如正正态布。每次做选择后，智能体都会获得一定数值的收益，这个收益的数值遵从上文所说的概率分布。 ¶-方法 ¶价值的概念 将在时刻选择的动作记作，并将相应的收益记作 。任意动作 对应的价值记作 ，是给定动作 的期望： 表示随机变量的期望 ¶动作-价值方法 智能体不可能从一开始就能够知道每一个动作相对于的真实价值，即该动作的期望收益。对动作 在 时刻的价值估计记作 ，它的值越接近 越好。一种自然的方式就是通过计算动作获得的实际收益的平均值来估计动作的真实值，称作采样平均法。 即之前选择得到的奖励的总和除以被选择的次数。当分母为零时等于初始值，当分母趋近于无穷大时，根据大数定律，会收敛到。 特殊的，若收益的方差是0，那么贪心算法在每次尝试之后都会知道每一个动作的真实价值。 ¶贪心算法 贪心动作：若持续对动作取样估计，在任意时刻都最少有一个动作的估计价值是最高的，将选择最高估计价值的动作称为贪心动作。 开发exploiting：从所有已知动作里做选择(估计价值最高的) 试探exploring：选择非贪心动作，是在所有动作里进行随机挑选 如果时刻可以无限延长，则-贪心方法可以使得每一个动作都被无限采样，从而保证趋近于。最后选择最优动作的概率会收敛到大于，即接近确定性选择。 实际上上述精确结果是，为价值最高的动作被随机选择的概率。计算如下： 在时刻趋于无穷时，每一个动作的实际价值都被估计出，则选择“开发”时一定是贪心动作，选择“试探”时则有的概率是贪心动作，即为 贪心方法在最开始会增长得稍微快一些，但最后稳定在一个较低的水平。从长远来看，贪心方法表现更加糟糕，因为它总是陷入执行次优动作的怪圈。 修正日志：之前把“动作”写成了“策略”，这样是不对的，这是两个概念，现在已经改过来了 假设收益的方差很大（噪声更多），为了找到最优的动作需要更多次的试探，-贪心方法会表现更好；若方差为零，则采样值就是真实值，贪心方法会表现得最好，因为它很快就能找到最佳动作然后也不会进行试探。 ¶跟踪非平稳问题 非平稳问题是指动作的收益概率随着时间变化的问题，动作-价值方法往往不适合处理非平稳问题。 ¶增量式实现 现实意义：传统的计算方法 在每次动作被选择后都要重新计算，并没有利用到的已知作用，随着已知收益越来越多，内存和计算会随着时间增长，每增加一次收益就需要更多的内存和计算资源对分子求和。类似于从Lagrange插值到牛顿插值法的思路，强化学习用增量式实现： 式(2.3)叫做更新公式。它的一般形式是： 新估计值旧估计值步长目标旧估计值 左箭头表示赋值的意思 ¶指数近因权平均方法 式(2.3)选择步长为，此时为平均采样。若动作的收益概率随着时间变化，还采用取平均值方法就不合理了，应该给近期收益赋予一个比过去很久收益更高的权值，一种方法是使用固定步长。则更新公式改写为： 其中 const，展开式为： 将此称为加权平均，因为可证明权值的和为 prove： 令，则，进一步变形： 即， 故得证。 ¶收敛条件 第一个条件要求保证有足够大的步长，最终克服初始条件或随机波动。第二个条件保证最终步长变小，以保证收敛。 在固定步长的指数因权平均法中，第二个条件无法满足，说明估计永远无法完全收敛，而是会随着最近得到的收益而变化。 ¶一些常见的改善性能的方法 ¶乐观初始值 采样平均法和指数近因权平均方法都在一定程度上依赖初始动作值的选择，这样是有偏差的。对于采样平均法来说，当所有动作都至少被选择一次时，偏差就会消失。对于步长为常数的情况，公式(2.6)给出的偏差会随时间减小，但不会消失。 将初始值设置得偏大的情况称作乐观的初始值，这样设置的好处就是会鼓励动作-价值方法去探索，它在平稳问题中非常有效，但不适合非平稳问题。 事实上，任何仅仅关注初始条件的方法都不太可能对一般的非平稳问题有所帮助。 ¶基于置信度上界的动作选择(upper confidence bound, UCB) ¶梯度赌博机算法 ¶关联搜索（上下文相关的赌博机）","categories":[{"name":"AI","slug":"AI","permalink":"http://example.com/categories/AI/"},{"name":"RL","slug":"AI/RL","permalink":"http://example.com/categories/AI/RL/"}],"tags":[{"name":"AI","slug":"AI","permalink":"http://example.com/tags/AI/"}]},{"title":"David Silver 公开课笔记 01 简介","date":"2023-04-21T08:14:19.000Z","path":"2023/04/21/David-Silver-公开课笔记-01/","text":"¶摘要 David Silver深度强化算法学习，第一讲——简介 由 Reinforcement Learning An Introduction (Second Edition) 第一章整理而来 相关习题答案 Reinforcement Learning An Introduction (Second Edition) 第一章、第二章 ¶Markov 性质 状态分为智能体状态()和环境状态()。 Markov 性质：下一时刻的状态完全由当前状态决定，与过去状态并没有太大的关系，所以可以直接抛弃过去的 History，数学表示为： History 给到的帮助比不上状态表示法，即可以用状态表示整个 History ¶一个案例 实验背景：有一只老鼠，假如按照作者喜欢的方式做，就会得到一份奶酪，否则会被电。老鼠被给到两个序列，通过试错进行学习，老鼠需要预测第三个序列会得到奶酪 or 电击。如图 电击——与最近的状态很像（lights, levers, bells） 奶酪——bells, levers, lights 数量与得到奶酪的序列一致 Agent 如何预测下一个状态，与他的状态表示方法有关，状态表示在某种程度上决定了未来会发生什么。 ¶观测环境 ¶完全可观测环境 Fully Observable Environments 智能体能够完全看到环境状态的变化，或者说观测到的环境状态与智能体状态完全相同。 满足这个条件的情况叫做 马尔可夫决策过程(Markov decision process (MDP)) D·S ： 希望大家能够记住状态表示法的观点，因为没有任何东西都是完全可观测的，这对于理解如何解决现实问题来说很重要。幸运的是 MDP 会帮助我们处理这些问题。 ¶部分可观测环境 Partially Observable Environments 部分可观测环境下，智能体并不是直接观测环境，因为他并不能见到环境的所有信息。此时的智能体状态不等于环境状态。满足部分可观测环境的情况叫做部分可测的马尔可夫决策partially observable Markov decision process。 例如打牌时并不知道对手的牌是什么样的，贸易时并不知道是什么推动着价格的变动…智能体并不知道全部信息 ¶强化学习智能体的组成 智能体由以下三个中的一个或者更多组成的 策略(Policy)：状态到行动措施的映射 确定策略： 随机策略: Policy 是非常重要的，我们需要了解 Policy 从而获得更多的奖励。随机函数可以帮助智能体拥有更多的状态空间。 价值函数(Value function)：对未来状态收益的预测，数学形式为 智能体的奖励是有步长的，是一个小于1 的权重值，用来将顶未来收益对当前决定的影响。 模型(Model)：智能体如何感知环境变化的，其实这并不是真正的环境，而是智能体眼里的环境，Mordel就是用来判断环境变化的。 包括两个部分：状态转换模型(Transitions Mordel)和奖励模型(Reward Model) 状态转换模型用于预测下个状态，例如环境的动态特性， 价值模型预测下一步的奖励，，预期奖励是基于先前以及当下状态的 Model并不是必须的","categories":[{"name":"AI","slug":"AI","permalink":"http://example.com/categories/AI/"},{"name":"RL","slug":"AI/RL","permalink":"http://example.com/categories/AI/RL/"}],"tags":[{"name":"AI","slug":"AI","permalink":"http://example.com/tags/AI/"}]},{"title":"强化学习食用指南","date":"2023-04-20T20:00:55.000Z","path":"2023/04/21/强化学习说明指南/","text":"¶摘要 关于一些网站的整理和总结 先分享一篇比较入门的文章：https://zhuanlan.zhihu.com/p/34298295 ¶教材选择 均由 David sliver 在课堂上推荐 An Introduction to Reinforcement Learning, Sutton and Barto, 1998 篇幅较大，400多页，讲得深入浅出，认真学过之后能学得很好，已经被翻译成中文版 Algorithms for Reinforcement Learning, Szepesvari 很简短，不到100页，比较晦涩，从数学原理角度出发，适合喜欢剖根究底的人 ¶练习题解答以及例程代码 ¶代码 官方代码，由Richard S. Sutton分享至个人主页 Re-implementations in Python by Shangtong Zhang Re-implementations in julialang by Jun Tian Original code for the first edition Re-implementation of first edition code in Matlab by John Weatherwax ¶课后习题答案 传说中的全网最全答案 RLbook-2nd-Sutton-Answer.pdf，分析过程有点草率 知乎-强化学习第二版-sutton,Barto著 练习题答案记录，思路还算清晰，但缺点是只有第一二章 GitHub-borninfreedom/rlai-exercises，只有前三章。 GitHub-LyWangPX/Reinforcement-Learning-2nd-Edition-by-Sutton-Exercise-Solutions ¶关于作者 参考来源：深度强化学习实验室 ¶Richard S. Sutton Richard S. Sutton 教授被认为是现代计算的强化学习创立者之一。就职于他为该领域做出了许多重大贡献，包括：时间差分学习、策略梯度方法、Dyna 架构。Sutton 博士进入的第一个领域甚至与计算机科学无关。他先是获得了心理学学士学位，然后才转向计算机科学。 目前就职于加拿大阿尔伯塔大学计算机科学系与Google-DeepMind，他的弟子David sliver正是DeepMind创造AlphaGo的带头人。 个人主页里分享了本书的PDF（是会修改的），还放了书本的勘误以及书内相关的程序代码：http://www.incompleteideas.net/book/the-book.html 更多详情请见个人主页 ¶Andrew G. Barto 这位大佬是“教父”的老师，那么就是祖祖师爷。 Retired Co-Director Autonomous Learning Laboratory College of Information and Computer Sciences 272 Computer Science Building University of Massachusetts Amherst 个人主页 真所谓一门三杰: Andrew G. Barto,Richard S. Sutton, David sliver ¶课程学习 ¶学习视频 选用David Silver 的深度强化算法学习课程，均来自哔哩哔哩 【中文字幕】David Silver深度强化算法学习 +项目讲解 【英文字幕版】深度强化学习（David Silver） 中文字幕的翻译更加准确一些，该英文字幕版也是在众多的英文版中挑选出来的比较好的一个视频 这里也被推荐过一个伯克利大学的教学视频： 【官方授权】【中英双语】2019 UC 伯克利 CS285 深度强化学习，优点是有人正儿八经在翻译，课程资料在伯克利大学官网公开。 ¶课程资料 课程PPT，作业等资料已由 David Silver 分享至个人主页 课程资料链接：https://www.davidsilver.uk/teaching/ ¶实践篇 一些算例 Gym 库托管 Gymnasium Documentation 动手学强化学习 David Silver强化学习公开课中文讲解及实践 ¶相关文献文献 知乎-DQN 从入门到放弃1 DQN与增强学习 几篇 DQN 算法的经典文章 虽然将深度学习和增强学习结合的想法在几年前就有人尝试，但真正成功的开端就是DeepMind在NIPS 2013上发表的Playing Atari with Deep Reinforcement Learning一文，在该文中第一次提出Deep Reinforcement Learning 这个名称，并且提出DQN（Deep Q-Network）算法，实现从纯图像输入完全通过学习来玩Atari游戏的成果。之后DeepMind在Nature上发表了改进版的DQN文章Human-level Control through Deep Reinforcement Learning，引起了广泛的关注，Deep Reinfocement Learning 从此成为深度学习领域的前沿研究方向。 而Hinton，Bengio及Lecun三位大神在Nature上发表的Deep Learning综述一文最后也将Deep Reinforcement Learning作为未来Deep Learning的发展方向。引用一下原文的说法： We expect much of the future progress in vision to come from systems that are trained end-to-end and combine ConvNets with RNNs that use reinforcement learning to decide where to look. 从上面的原文可见三位大神对于Deep Reinforcement Learning的期待。而显然这一年来的发展没有让大家失望，AlphaGo横空出世，将进一步推动Deep Reinforcement Learning的发展。 关于 Human-level control through deep reinforcement learning 原文链接：【1】Human-level control through deep reinforcement learning 对该论文的一个复现代码：https://github.com/tjwhitaker/human-level-control-through-deep-reinforcement-learning 【2】Playing Atari with Deep Reinforcement Learning","categories":[{"name":"AI","slug":"AI","permalink":"http://example.com/categories/AI/"},{"name":"RL","slug":"AI/RL","permalink":"http://example.com/categories/AI/RL/"}],"tags":[{"name":"AI","slug":"AI","permalink":"http://example.com/tags/AI/"},{"name":"高效工作","slug":"高效工作","permalink":"http://example.com/tags/%E9%AB%98%E6%95%88%E5%B7%A5%E4%BD%9C/"}]},{"title":"线性代数-特征值与特征向量","date":"2023-02-17T13:31:22.000Z","path":"2023/02/17/线性代数-特征值与特征向量/","text":"¶摘要 ¶证明\\lambda的n次方是A^n的特征值 因为是阶方阵的特征值, 故有维列向量使得, 于是:","categories":[{"name":"Math","slug":"Math","permalink":"http://example.com/categories/Math/"},{"name":"线性代数","slug":"Math/线性代数","permalink":"http://example.com/categories/Math/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/"}],"tags":[{"name":"Math","slug":"Math","permalink":"http://example.com/tags/Math/"}]},{"title":"Pycharm使用技巧","date":"2023-02-05T03:29:41.000Z","path":"2023/02/05/Pycharm使用技巧/","text":"¶摘要 在使用 Pycharm 时，高效的使用方法能够提高科研效率 ¶查看变量 Run菜单 - Edit Configurations 菜单 勾选 Run with Python Console 运行，之后可以看到变量 https://www.cnblogs.com/emanlee/p/15186235.html ¶分块运行 1234567# pytharm 分块运行# %% 第一部分import ......# %% 第二部分import ...... 然后在View下找到将Scientific Mode选中 通过# %%定位的地方就出现了绿色的小箭头，点击绿色小箭头就可以执行这一行或这一块了 https://blog.csdn.net/weixin_42690752/article/details/103878822","categories":[{"name":"高效工作","slug":"高效工作","permalink":"http://example.com/categories/%E9%AB%98%E6%95%88%E5%B7%A5%E4%BD%9C/"}],"tags":[{"name":"work","slug":"work","permalink":"http://example.com/tags/work/"},{"name":"学术生产力","slug":"学术生产力","permalink":"http://example.com/tags/%E5%AD%A6%E6%9C%AF%E7%94%9F%E4%BA%A7%E5%8A%9B/"}]},{"title":"学术论文写作","date":"2023-01-15T12:21:52.000Z","path":"2023/01/15/学术论文写作/","text":"31568d710e28da3e9920134e13d5e8646d9d9a6d4f053e2bb80501ef4445d3b2e13a8b8d9351c7935b76562289879604dccf01c53dfb658882b0fc830e86f24966f592f59360aa663e88f72f656c9a3529daea590431ef837229eb9c74fc5143ca03bd191c7134110050f53d153b67b2d786a19008bcdfa86b741d99ad268493b9af50ce9f7886b429a6a10b7688ea1f3b9827982d0c1174b790437f590d5624ebb376da5dcb3c5ec2f2940211340df0fd64123ae4120cf94361616daea590cd3dc20849f1b97fff2f43d987692c0846f29a7edf97850fea79235cbe484607252de65797cbb5b32850bf8fdf2e0c7f5acdf3dbe537f35d0421ac8e29942f09233547764c48a470952f88685ee7932f37e3b2a08c3055056569826f630c033f19eb9200a85731ac66ff80d00aaf9fb2c67b6082c0f6551c1a82a3e146d83435e7d53d673f753714eff853a491cb23436805ec4d5d7e987ded494d9a321db68cb0b8938ffb832e7071c64535a0fd2fc897a04fd750ea6827e6e8b6763c66eff880db5e3753233214b41042bbd08bdb2bc07a9b24ec5b8f26c95db28ebf250f226a45c260ba4a03501a89ff65ac5de3ccdd8f28ed87be26a20d17cd8fa3fb1d6597b5a9c91f3e24e97ce7d927bd3b7d6b33f31f69fbe14c632a15c56c908513128cb72f0fdaf0da0e316b151f952631255b848b18a6b63aec68866d2fedad7f867065184480fee0cfc0457f7d309ec63bf638b83d964b1cccad4326a13c1dfd39baabcbb81219249453f731482d63592faf19384bc68376a1e347d687907fd582c6b71aae9e8f7b94d05eb841ab89264e642e6da50cb817178c035c8744b51de81e229eec3634ac7ec8affb849482466e603aac11381b308cb858b399f5bf41cbe0983292fd292da1f3b30fc08103226e833722d984501232505ed709a89ee2aed3425b12481b38e3bf660d52ddb599882d5967a9f2c089f0233857a522db4f1765b234bf25bc962568647c514e39126ccecc1c7df814bfccc016861dc374b2e48acf417dc47f2170c6abf5108fa0b66200ce78d44fc7e1012132fd79cec1f235e71c0bb7979b3ac4df275150d140cdbc94cca9de6e096959902db0efcad5c1130232c52981b70acf9ac7e55f8afcd0c91f6bc76b8e327695022d79abbcd5153619c387123aa3a491574b83e6784d766b8036a4af3568fbf4246ccc755c772a03df5c377f3d9b30ba7a595abb668b12a613e3d122478d5c0dd3bd5db6908d569a454be0c1299327dba9d81c24c2deda3bf6133277ef6bc527d2458fb0c7b0b8ef6ce18535356d2da97519359e048aab5fa4bc5aaa2626a0c904ebecc412d7ca5b381b8f6e9a202420f0621f1be20304d6c0a5280637e9f970d5e50549b45f3fb78c7e25d791a953eab1b05fad6adee7a3845a5926ea0dd4bdc735a40bd0dc1aff41e741b70730b8790f672d3cc5d710d61b1e8c81f7421868e7f9be8f1a5830f632e3aafa3f9f70292e717fb7ba2fc459564aea5f933a344d8a2bab78a933dc32466d77ba110ecad8b128cf1e9ea1e644efface1993c9f1c3b62ef322526459b9ccdaefe4221d5cdc71c057fc7c9755f3ab1e4ace0562b6e3ab70451c7b743a3fb1bb30f1b2b9c0c9e53b0b73563f5127c4360693f7ea8362b79bfc13bb384f57b422bb8d329a2979bc324fb797358eb0e08632d17ba3aa6e8c7ce982d4cf4e05a6ccbc92ebb99a95580c911138f97d1cea857bf4bfcd976773c6076ab7dd62bf811a77d0cc86be816e47a1a4d050c8d7976f076f60d86b5e10c12342bf73fbd3eb92ffd1886b373217ff8fba613aef50c63bfcf75acf54f9f5f17e67a3d58583e08511a38a6f9de07f9a0b639da9073699f27420f4df360033e5a20e6ae1b40458910500adb05e21a39080c0bb50902458bc066a283f616b12b02e39a77acbced80b5adf9661dd54df3411d120c0d4af8626a810c5c67fe8aa3095e29322c85091f89d494a5654788f085f90e18f53501c7250e2e983c3396e5b244b984a1bf951d8ffcfa76ba2d510c4b49c977877148653db84a9121cf0867878bde7a029531558b4d77964f33853d993c5e4d60a1976aba945e28366c07d21f0ef7940d919a85574e780addea51881ce5470ac5c8fb068e9710d7a0cebb21325cfe455232a9c62404f6cf56d6cbbd981cdd66d041a31cf908429f0d6ae1c21695a1c3994e3a6b36945488d7015edd782e3b963498241844fe5ff8cf6559d95170b3978c04f6417ccb85bd37783603ddf2b3b98c77750247ff152eb27ac1bdca1a79f1cbfa52a4ebd4de160b6c2a701ae2b7681f27f212da581f0d42dfb3f18cdd08826bdc63ea67cf86ea58fc10d66180df885191e212aa976932f6b13138ad11f5aca7dde7ebc9aa98ddcdaabda857dc4d2395aba61d71949c93c0f76d544e5c8aa7433f39380c0bdd735fba380db4f29f3343e2209e2b00bc7d77864a15e3e179e42517bfe38048938386083c4975b91f322d7c5e16ecdfedc108fb4b636098f40092b29ad5fafdfea7b3f9006763fc331aa248f9c5bc00e3ba592a05ad075c1a5fba329920078b398da835904f718b3605c689174448de146a9177bbb627c4532c8ee9f95317961ee10fae9468302f2639feeee410e878d6a25e47ad52b3ad5279484f99b492dbe0d00c75bb8c5962d391a0a93964e90e4d1046f6ac1c1b20ad1c69d69135cfee47ef33aca8a7d27c0de7dfb9835ade30f72230855f6ef2c18145376d91b6e7be880597d13163be3895a7c865ae4b143a9a937c0f4d7cdb529bc169647ccf315f725c447532b94d8403ad85a6e96984eec383ff1007b2c793b565d084e70464bb457b3b75503afd342ba89e70fa6707960f125bd9ac4c473d1ff62340917f2cf1e6437f1a5d7698cda829719349fd3cb6c5ab8e1f36b4634ad03f6040ab01b4636c0d7d33f223750b7975b6ac0d4ef2060506716dcdae2a15aab2d9c4e8d3281168890b95efe93bf7542da6c93dcbe5f3c726fd72518e0979fcf959d2b30b2d17d909403fe17e0261d06f6cf34c97fd31e926bcc2c4b51a1e70ba9dfa979b767e181acbb479695ebe7f2e0a5d54bdbfd37f14f34427d90f1a23dd805c22ab771c264e352558e64ec842f3aaca66c4488a8e855c2dfb251b0a10332d6c1983da34823b770b8e6162f54e63110f32e2e926bd4747bc2103e75acbf72bb260052ff2205f07ecb78431538df47bc51f9d687750300a5e4b1a216e9ddbcd2500483a8428da37f25ec4e9821fcf144a353c3417c06a94ce3f806e9638e802191d0ac2758b0387134bf0b71d1965956217c1fe8cd00b0d01ce6b2208b3ce4a31ca1d5fef26d5ba3db9396c2925b24410a6ae8a5f95a72072604c1d096246893dcd56e3d8acb35e295f3bbc2f9515bd732d9dc386b5297fdfb01aeee5ac280a21da630c356aee92a403c79934303af8328b39ee52d04c8d0524c03d629f89dd0e9952707b0721395bee6d11400415410fa61ab4acbd322ae46f0b60bd5261d906318da7d1fe2e3d275e08da1ce4a74a316364fe49ef9f641c3e6df9f6d6fa42344352f363245f0a2c46045e93067f89da9c31ad2f2d0f04276db9cce2df48e0508d0b4fe95cc398587ce9d144898194e396128217740cf00bc4f9bdcf0e481a3af526fa10bb35cf6b28200c10b78df572058bd2b9269c8d5e3a8ee6addc756955f5e374548af5e7957c2ebcf4b108e74bfbe8676f8188059c84ae67a7ab022654f1de24a0669d62b019a1cb3afb5b3119a3e771db7273367cd47a9380ab4ba95905bdec0df48bc20005009acd82d25bbd40a8e08fd47ec0a43f7e77445cbf8849dc07da0351e1474a1dcb220c0ba4bb84fcd7a41435df9e0fac61f08ad064a934a9863631abdbf92db1384585286c9dada62705f929b24cf077f736bc928fcfd9e98c6fac989c205fac2e3a20f146c984d791befb2ec717ed0579b8987449739a93e92193a64ba172248b740568e3699481d87d8324d926fe56a7b157d0bba812dd5a15b22e61f643addc98fc4ea7038aa3934eb581bc82cd563f0a97c26f013db42f3deadae0e394e15c38f8e72e00a4363ae8123d7eb4a83d2d34ae695ecef6817439ae4f405b9a7cb9c4f401b5d4a4d7e2c218195a00db2d209a3cebdbc42808fffe32b215982f43ab0313c35db07201c858bfb8a536eeb62ef33e3f47cdb33b4796cf729d4d0afe5faa9a2afb1ee1cb3b92968ffd0a47796d4ca9f21ce8ee7a0dd61209846e40fd0ad82d73a6b6cf091120e4c28fe4b23bba8fe8702c722f4ecb24195591768be6a9c761b4cb9abd99bd01ec21b9df5d77041b083b329bbd24d0c4abc8d884b402ea074d219b73a2a2bd5e355582a6ca3cacd352d92b1a79e58c7fa37092e2908ea7f701813652459b69348f9939f6418a9143042a0221cd506fbf66bb6370fb29a96c61a54a3f99c2511b0a1a8b2caecefe4b73f2fb92a023e753506a2761955a7b37a0449e1c3f9b2603d1c6862e00da9e4e6b4efc319246a59527fe77947b0523ce7251abfcaf02866607b6de369605f01f204be0eb3c1bb240b3df3da6edae280e5853f250aed4ec5bcafe1a93c7fbd197ada11fb67c69346adac92d18ef32bb3e2770508fde124ac6fbeaca8195f472aaa40e125e8d2e1f045b42ea0bb9a7d26f75371bb97766a6e0172de0771106263f2843200773f750a1cc47b6d6d79e06dde2e3e6de33a2a2f7d3929de95c6669a9bf7ae1edc5d630fb157c4b346d25fbf9afeb0b2b91eca914ddd86fcdef0c33a9a56b516ff40ea14b0edb0c9f530b56b035b5b176b90207b747f12cd266f49931b28b035f5964b40657b9f78fb8fecb4ec0a91be3b46f56d709f44aecc74d7307ef35a7e05967c6c2e38f21c87c5c9bc028d3cf5614e73395bcc658756f732e4d0827ce1921eab30fe25cd9b71d2cca41ebade3cf07c080ecd1e1b50e581cacde54583515bd98e15b36687c74bd55798dcc507f661eee82d6ee4d53156d5a87e06e98a0ac24074f817bfe0f54bfe7e8e034eb5bf515f1ee06dcbf37d6a2db739f27941e92b881ba273a9b8e314ac64c00bc1f8a2e8bf2e85b8cdff1b0847c307360d9ae6acdcddd28cf7a7707ecc3e91688734b0fbe5f12f1e3ba734c3bfd7f1eec63574d30908a844df6d46b8c614411fc0fe7aa66fcb804f5a8890ece8aafd17e01bb68dd720b7a47bb1d649f87237c9568adaf003ce5ab0c076e6e4ba8aad107c571b4e8f3d09846099078cf937d9b2b4a19ddce1046d6f10df9df6a309ff183f289ae496d28ae24c5be7adb2287e93ac2de7b654d1c663b47ecad16fe3e966aa3a181fc2d950446cb3ab55afb1f87e205f832589940eb5c53db69c9ab7f691319050cbc626e29ef2841a8658c377f98aa8b0ee6b9371754658a1d9be8f47c6cb7570e1b66d8a8f2b41097d477af6059a1351c80681e2a92c7c33f0112f34eb3ecf1cd353934b443f89c6fa246d35fd35916f323d549c02fc15dda155d10f5ceeba44720f3ff16498c3a9f2b132558393bede6bad4d473e819ddc28721d5933a933602c16f4e6e47cea9d8b1a35c13ac78df4d033e79afa2059954f8df9b34efa54806bd13f773d0b4b0aa07668903eec594465d1fb3b34d94502dec5dd1b029f4e9047dd1b416b12eb8829943711265c1f034c298763e3ac4a9bb1370e9fa8cf87a4887f19fff0c2ab590c11a39e0870cfb1178f7fc0f27b0e8215c41e7cb37828ef3e12588fc7cc388b9196cd26352e6a008a474c6c59c7cf8c5fa837c702eee57596965c5c827ad0a81707d0f6d2df6f897cc3772bf766886c56eb1cf9bb5f322e7d44e8d6e6b155fb69480614f9e75fcb5ca06e049c829bc0b62f6ca2d9e1092fdf4f738dd17bc87203e5ba1d8efcc7b2b4f36a71e132b7a03f293c58e3709f90a162f80198a5192b4b23f66c8abeb74bc8c3969e7235549fa8ec2a5226482c773481cb5daf926dfef01255d3000651e222daaeb74f7b0265eaf1012fda32dd721c1bdc7e181b85ce7590329b17e8bfd7102040b021d5066c149c5b54a2e75fd3039f751eff775bd1c42efb165d99b35b0d15c0b6f65103dbb7a02ec682ace9237d6aadede29e8be85f5ca811c8156e5a02818f75989d54588dc64aa2c08b9852580dab3fc783c56ed845edf7b5843255ba79d238f1baeb408eea4250c5b0a7d49ead17927a00bae9930261fb8f5d9db13c3ebe175107657bf16610cdf033161fafec8f1f93cafb11d990f1d60358ea6eaace9dbd420a4db88c067615f8afc50f16d5a3b18905e889189e19be4cdacd9f3b4a400c807ef6a9d906e99698e984bf60ef74c05e725b79d1110daeaf56f841ae1652b241cd879888e51750ed09394eb9cb100f8807b5de5b546e7919c4982c88a54e7d255469783d88c259acd090c1dbb29636225c7feb728973a645588b4cad6ac805ba8decee67aaf1d7fab4f17a0d56f54eac98b33a595fd0283c843d4ea3e4d14dc2825d8edbcc17c2968e2b570f4554264d624eeb3b21826d23061e9e6d34d9a5751d29e865c22e3a218f806fd9f7d0d7366101a5095a05590208869b8b9bf459c78ae8ee336e43629464ed7c6945a54f464050f8db99ea37a4a6d38fa66b7e49a308353eaab0d204ef3bfd8c35bed085f9038d53c4b6c39a2ea21262a766ff4a10d9c2c8a7f24f2554dc8e7e5ec40a03ab0a8dcc4e2fb52229daafe45ecc8f6f3c6fe65f799aa5e58854b021dee7bf4a2bb551a055667e08685275edbf04acba27c472001829eeaebaa10b981da0bfe74583ead1724198434122d1adfdeb21f4bada38433ceb27e69b106f43d43b0e4f354eb611691dbbf89c0d3d87ee732cb219ffd9ebd2354471475f9e9ae39de1a58c8a60ec25cda12e1d7b11452e5a3ce11577162a337013d669c335a3690c4ece15141cbe2a7ddf8d1a415fd203408ac212386da613321dd23238166793e1039995230bdbecc301ad1089f0591cdcf60c1c3ee9e9701505e284eb58eb43b52a16afa62fde12bc0d8a962104a6683c293de233bb8c96586ceabd3c91a2a1dd971912db9d5d558615d62ddc72f32a76136a725840a53fb2f850a41805bb5419c24605365ff9d33c0ce9d2480d2b7aee2b8b70cf8d598c5eb1552ce230ba57ba1db66e34ddb8f5a41663cee17220221d01 您好, 这里需要密码.","categories":[{"name":"高效工作","slug":"高效工作","permalink":"http://example.com/categories/%E9%AB%98%E6%95%88%E5%B7%A5%E4%BD%9C/"},{"name":"学术写作相关","slug":"高效工作/学术写作相关","permalink":"http://example.com/categories/%E9%AB%98%E6%95%88%E5%B7%A5%E4%BD%9C/%E5%AD%A6%E6%9C%AF%E5%86%99%E4%BD%9C%E7%9B%B8%E5%85%B3/"}],"tags":[{"name":"work","slug":"work","permalink":"http://example.com/tags/work/"},{"name":"学术生产力","slug":"学术生产力","permalink":"http://example.com/tags/%E5%AD%A6%E6%9C%AF%E7%94%9F%E4%BA%A7%E5%8A%9B/"}]},{"title":"Hexo 学习笔记","date":"2023-01-14T15:05:32.410Z","path":"2023/01/14/Hexo学习笔记/","text":"用于存放 Hexo 操作速查 ¶基本操作 1234567891011121314node -v #查看node版本 npm -v #查看npm版本 npm install -g cnpm --registry=http://registry.npm.taobao.org #安装淘宝的cnpm 管理器 cnpm -v #查看cnpm版本 cnpm install -g hexo-cli #安装hexo框架 hexo -v #查看hexo版本 mkdir blog #创建blog目录 cd blog #进入blog目录 sudo hexo init #生成博客 初始化博客 http://localhost:4000/ #本地访问地址 hexo n &quot;我的第一篇文章&quot; #创建新的文章 #返回blog目录 #Github创建一个新的仓库 YourGithubName.github.iocnpm install --save hexo-deployer-git #在blog目录下安装git部署插件 ¶建立文件 1234567891011pwd #查看当前文件、文件夹路径ls -l #查看目录（当中的文件）cd folder_name/folder_name/ #进入到子文件夹中cd ../.. #退回到前两级文件夹中hexo init #初始化博客hexo clean #清理hexo g #生成 hexo s #启动本地博客服务hexo new &quot;My New Post&quot; #新建.md文件hexo n &quot;My New Post&quot; #新建.md文件vim PostName.md #编辑.md文档 ¶部署到GitHub仓库(W10) 123$ git config --global user.email &quot;2023*******@qq.com&quot;$ git config --global user.name &quot;usename&quot;hexo d https://usename.github.io/ 访问这个地址可以查看博客 默认在本地 http://localhost:4000/ ¶Hexo 博客加密 使用 hexo-blog-encrypt 插件: 操作步骤: https://github.com/D0n9X1n/hexo-blog-encrypt/blob/master/ReadMe.zh.md ¶安装: 1npm install --save hexo-blog-encrypt ¶配置 修改 scaffolds 文件夹中 post.md 文件, 添加语句: password: &quot;&quot;, 默认没有密码. 设置优先级: 文章信息头 &gt; 按标签加密 表头信息: 12345---title: Hello Worlddate: 2016-03-30 21:18:02password: hello--- 对博文禁用 Tag 加密 12345678910---// 只需要将博文头部的 password 设置为 &quot;&quot; 即可取消 Tag 加密.title: Callback Testdate: 2019-12-21 11:54:07tags: - A Tag should be encryptedpassword: &quot;&quot;---Use a &quot;&quot; to diable tag encryption. 在配置文件: 12345678910# Securityencrypt: # hexo-blog-encrypt abstract: 有东西被加密了, 请输入密码查看. message: 您好, 这里需要密码. tags: - &#123;name: tagName, password: 密码A&#125; - &#123;name: tagName, password: 密码B&#125; theme: xray // 不设置输入密码主题则不会出现输入密码页面 wrong_pass_message: 抱歉, 这个密码看着不太对, 请再试试. wrong_hash_message: 抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容. ¶公式渲染问题 用\\bm指令无法正确渲染公式加粗（下），改用\\boldsymbol指令即可（上） ¶Timed out 有时会显示“fatal: unable to access ‘https://github.com/Name/Name.github.io.git/’: Failed to connect to github.com port 443 after 21094 ms: Timed out”, 这是网络问题，解决办法是把VPN关掉。 有时候关掉 VPN 也不管用，采用 GitHub desktop 上传，参考链接：GithubDesktop与Hexo结合使用,解决博客更新问题. 2023/08/03 更新： 情况：将VPN关掉也不好使，会出现SSL问题，偶尔能够部属成功，找到原因是之前下载过的校园VPN卸载不干净，在文件夹C:\\Users\\Public\\Sangfor\\SSL中留下了一些东西，删除Sangfor文件夹即可。 2023/08/14更新： 情况：将Sangdor文件夹删除后依然时灵时不灵，关机时会跳出&quot;Sangfor P…&quot;阻止关闭计算机的字眼，打开服务，找到Sangfor …，考虑到以后还会使用校园网VPN，就不删文件夹了，将设置为禁用 2023/09/10 前来更新，这个代理还关不掉了。。。这样来取消代理： 1234git config --global --unset http.proxygit config --global --unset https.proxynpm config delete proxy 参考：git 设置和取消代理 解决 Failed to connect to github.com port 443:connection timed out ¶OpenSSL SSL_read fatal: unable to access ‘https://github.com/usename/usename.github.io.git/’: OpenSSL SSL_read: Connection was reset, errno 10054 一般是这是因为服务器的SSL证书没有经过第三方机构的签署，所以才报错，查阅过很多方法，都是说要解除ssl验证，但是这种方法总觉得不安全，放弃了。 其实是邮箱问题，解决方法: 查看用户名，邮箱 12git config user.namegit config user.email&lt;/code&gt; 修改，用户名，邮箱 12git config --global user.name &quot;xxx&quot;git config --global user.email &quot;xxx&quot; 虽然经常检查邮箱没有问题，但是重新输入一遍还是管用的。问题解决, 了如图: 但是出现了一个问题: 12345678warning: ----------------- SECURITY WARNING ----------------warning: | TLS certificate verification has been disabled! |warning: ---------------------------------------------------warning: HTTPS connections may not be secure. See https://aka.ms/gcm/tlsverify for more information.warning: ----------------- SECURITY WARNING ----------------warning: | TLS certificate verification has been disabled! |warning: ---------------------------------------------------warning: HTTPS connections may not be secure. See https://aka.ms/gcm/tlsverify for more information. 回去仓库看了一眼, 发现多了一个 main 分支: 解决方法: 删掉 master 分支, 将 Hexo 的 _config 文件中的 branch 改成 main 12# branch: masterbranch: main 学废了, 转战 docsify 去了 …迷惑, 电脑关机, 第二天把 public 文件删掉之后上传就莫名其妙好了, 还成功生成了一个页面.(怪事) 后来又把分支改回了master, 记得去仓库那把 source 改成 master 参考资料: csdn-fatal: unable to access ‘https://***.git/‘: OpenSSL SSL_read: Connection was reset, errno 10054 阿里云开发者社区-OpenSSL SSL_read: Connection was reset, errno 10054 2024.5.22 补充 这个是换号的原因，本地凭证还是老号，下面是报错语句： 1fatal: unsafe repository (&#x27;D:/class/language/Hexo/blog/.deploy_git&#x27; is owned by someone else) 这篇文章真正帮到我了：阿里云开发者社区-github多账户切换 然后还有一步， 检查.gitconfig文件（C:\\Users\\username） ¶npm [WARN][ERROR] ¶global npm WARN config global `–global`, `–local` are deprecated. Use `–location=global` instead. 修复这个WARN花了我半天时间，最后在overflow-Message &quot;npm WARN config global `–global`, `–local` are deprecated. Use `–location=global` instead&quot;上得到了答案。该问题出自Windows系统的，解决办法是更新 npm。Upgrading npm on Windows doesn’t work with npm itself like on Linux. You have to use npm-windows-upgrade to update the wrapper script npm.cmd at the right location. 参考Upgrade npm on Windows 做法如下： 以管理员身份运行 PowerShell 输入 Set-ExecutionPolicy Unrestricted -Scope CurrentUser -Force 然后，为了安装和使用这个升级器工具，请运行以下命令（也可以从高位的PowerShell或cmd.exe）。注意：这个工具至少需要Node v6。对于低于4.0的Node版本，请使用npm-windows-upgrade@3.1.1，对于低于6.0的Node版本，请使用npm-windows-upgrade@4.1.1。 输入：npm install --global --production npm-windows-upgrade 输入：npm-windows-upgrade 输入：npm-windows-upgrade --npm-version latest ¶command not found bash: npm-v: command not found 在 Git Bath 中输入 npm -v 得到该错误，在overflow-bash: npm: command not found?得到的解决方法有: 关闭 Git Bash ,重启 VScode，开启 Git Bash；可以解决一部分问题，但我的问题仍未解决 在 PowerShell 中输入 npm -v, node -v, hexo -v后均和正常显示版本，说明是 Git Bash 的问题，后我又回到 Git Bash 中输入指令就问题就奇妙玄学地解决了… ¶[ERROR][hexo-renderer-pandoc] 这是由 nexT 主题数学公式无法渲染引发的问题。 ¶解决方法1：安装 markdown-it-latex2img 工具 在 issue：Error occur when set math render (设置数学公式渲染器失败) #1483下看到的网友的建议， markdown-it-latex2img 的特点： 可以将LaTeX数学方程放在任何地方 准确、快速，支持呈现多样化的公式 将Latex语法转换为图像标签 支持内联和块状公式 渲染结果支持多端使用，如微信小程序 markdown-it-latex2img 的用法如下： 安装 12npm i hexo-renderer-markdown-it --savenpm i markdown-it-latex2img --save 配置 1234# _config.yml 文件后加上下列语句markdown: plugins: - markdown-it-latex2img 语法：见Markdown-it-latex2img示例 开头的$必须在其右边紧跟一个非空格字符，而结尾的$必须在其左边紧接一个非空格字符，并且不能紧跟一个数字。 缺点是将公式换成了图片，影响阅读；语法繁琐，不够自由；公式中的空格被当作无用符号被省略，影响表达。但除此之外可以解决原有的所有渲染问题。且有时会出错，出现不能markdown不能正常编译的情况。 语法参考： MathJax basic tutorial and quick reference ¶解决方法2：更换 pandoc 引擎 使用这个 renderer 之前请确保你已经安装了Pandoc，然后卸载 Hexo 自带的 renderer，安装 Pandoc renderer: 12npm uninstall hexo-renderer-marked --savenpm install hexo-renderer-pandoc --save 注意：如果使用该引擎，那么书写 Markdown 时需要遵循 Pandoc 对 Markdown 的规定。有一些比较明显的需要注意的事项：正常的文字后面如果跟的是list, table或者quotation，文字后面需要空一行，如果不空行，这些环境将不能被 Pandoc renderer 正常渲染。 另外，文中的 URL 使用 Pandoc 渲染以后是普通的文本格式，不能点击，可以通过用 &lt;&gt; 包围 URL 的方式把 URL 变成可点击的 URL。 在使用该引擎时，发生无法渲染的错误，与 Pandoc 的 smart 参数有关，具体不是很清楚是什么原因，在博客根目录中打开 node_modules\\hexo-renderer-pandoc\\index.js ，把 args 变量进行修改： 12// var args = [ &#x27;-f&#x27;, &#x27;markdown-smart&#x27;+extensions, &#x27;-t&#x27;, &#x27;html-smart&#x27;, math]var args = [ &#x27;-f&#x27;, &#x27;markdown&#x27;+extensions, &#x27;-t&#x27;, &#x27;html&#x27;, math] 关于如何在 Markdown 中使用 \\LaTeX 公式，参考Markdown 中 LaTeX 数学公式命令 缺点是本人按照网友提示操作之后并没有成功，最后决定暂时采用的一种方法。 参考文献 Hexo 搭建个人博客指南 Hexo 书写 LaTeX 公式时的一些问题及解决方法 ¶解决方法3：插件hexo-filter-mathjax 2022.7.13更，实在是受不了了！！人在教室自习，后面坐着一个数学系同学，我在复习微积分，本来就班门弄斧之嫌，这公式还不能正常渲染，简直是颜面扫地！！！一定要解决渲染公式这个问题！！ 于是开始网上冲浪…看到了一个解决方法：hexo博客next主题添加对数学公式的支持-爱代码爱编程 上Hexo官网-插件-搜索：math，hexo官方提供两个支持数学公式的插件，分别是： hexo-filter-mathjax hexo-math 选择hexo-filter-mathjax，操作说明见：Hexo Filter MathJax \\ hexo-renderer-pandoc 先将主题配置文件中的math.mathjax.enable and math.katax.enable to false（不知道为什么，文档里这么提醒的） 12$ npm install hexo-filter-mathjax$ hexo clean 在Hexo配置文件_config.yml后添加语句： 12345678910mathjax: tags: none # or &#x27;ams&#x27; or &#x27;all&#x27; single_dollars: true # enable single dollar signs as in-line math delimiters cjk_width: 0.9 # relative CJK char width normal_width: 0.6 # relative normal (monospace) width append_css: true # add CSS to pages rendered by MathJax every_page: false # if true, every page will be rendered by MathJax regardless the `mathjax` setting in Front-matter extension_options: &#123;&#125; # you can put your extension options here # see http://docs.mathjax.org/en/latest/options/input/tex.html#tex-extension-options for more detail 现在可以将主题配置文件中的mathjax.enable–true 主题配置文件中的math中说： 12345math: # Default (true) will load mathjax / katex script on demand. # That is it only render those page which has `mathjax: true` in Front-matter. # If you set it to false, it will load mathjax / katex srcipt EVERY PAGE. per_page: false 所以我将per_page设为false，希望它可以自动为我的每一页渲染公式，但是发现并不是我想的这样，设置为true也不行。于是我修改/scaffolds/post.md： 1234567---title: &#123;&#123; title &#125;&#125;date: &#123;&#123; date &#125;&#125;tags:categories:mathjax: true--- 添加语句mathjax: true以后就不用每次都手动输入了~ 目前的公式渲染问题算是解决了，但我在多个博主的文章中都有看到，例如这位博主LinBaiJiong提醒说不要：安装pandoc插件，pandoc插件的渲染确实较为繁琐，不够自如，总是VScode中能够成功渲染的语句总是无法在Hexo中成功，期待更加优越的解决方法。 ----------更 听取了博主LinBaiJiong的建议，改用渲染器kramed解决了pandoc不能正常渲染标题；列表、表格、引用前要空行的问题。 12npm uninstall hexo-renderer-pandoc --savenpm install hexo-renderer-kramed --save 之后写博客更加高效！ 附：katex手册 ¶LF will be replaced by CRLF in . LF will be replaced by CRLF in js/next-boot.js. The file will have its original line endings in your working directory. overfloow-LF will be replaced by CRLF in git - What is that and is it important? [duplicate] 在命令行中运行： 123$ git config core.autocrlf true或者$ git config --global core.safecrlf false 什么原理不知道 ¶err: Error: Spawn failed 报错信息： 123456789FATAL &#123; err: Error: Spawn failed at ChildProcess.&lt;anonymous&gt; (E:\\class\\language\\Hexo\\Dynamics_of_Structures\\node_modules\\hexo-util\\lib\\spawn.js:51:21) at ChildProcess.emit (node:events:527:28) at ChildProcess.cp.emit (E:\\class\\language\\Hexo\\Dynamics_of_Structures\\node_modules\\cross-spawn\\lib\\enoent.js:34:29) at Process.ChildProcess._handle.onexit (node:internal/child_process:291:12) &#123; code: 128 &#125;&#125; Something&#x27;s wrong. Maybe you can find the solution here: %s https://hexo.io/docs/troubleshooting.html …好傻，被自己无语到了…解决方法明明都写出来了,还习惯性上网冲浪, 尝试了一堆办法没一个有用. 如图: 输入 1git config --global --add safe.directory E:/class/language/Hexo/Dynamics_of_Structures/.deploy_git 这时候事情有了一些转机: 出现了新的报错, 幸运的时并不是更加复杂的错误 12fatal: unable to access &#x27;https://github.com/usename/usename.github.io.git/&#x27;: Failed to connect to github.com port 443 after 21075 ms: Timed out 提示 time out 把就代理关掉, 终于又可以写博客啦! 纪念一下 2023/1/3 把去年堆积的问题解决了好耶! ¶fatal: unable to access ‘https://github.com/username/nsername.github.io.git/’: The requested URL returned error: 403 报错提示： 1remote: Permission to username/username.github.io.git denied to &lt;otheruser&gt;. 错误可能是，电脑保存了一个git用户名和密码，所以如果你转移到另一个账户，就会出现错误403。 https://github.com/trilbymedia/grav-plugin-git-sync/issues/39#issuecomment-546016249 解决办法- Windows： 移除原有凭证 Windows-&gt; 凭据管理器 -&gt; 找到有关于 的凭证并删除 这时候再尝试指令: ssh -T git@github.com, 得到 Hi username! You've successfully authenticated, but GitHub does not provide shell access. 表示已经可以正常连接了. 这时候输入 hexo d ,得到另一个报错: 1fatal: unable to access &#x27;https://github.com/usename/usename.github.io.git/&#x27;: OpenSSL SSL_read: Connection was reset, errno 10054 ¶fatal: unable to access …: HTTP/2 stream 1 was not closed cleanly before end of the underlying stream 使用git的时候发现一直提示HTTP/2 stream 1 was not closed cleanly before end of the underlying stream。通过排查发现，是git默认使用的通信协议出现了问题，可以通过将默认通信协议修改为http/1.1来解决该问题。 1git config --global http.version HTTP/1.1 ¶一级标题无法跳转 把 MathJax 换成了 KaTex，换了渲染器之后 TOC 就出问题了，TOC 条目没有链接包裹，跳转不了对应标题。 通过网上冲浪… 从几个博主那里知道这是 hexo-renderer-markdown-it 的问题。 ¶solution.1: 修改配置 参考链接： hexo-renderer-markdown-it/Options 文章目录的一级标题点击不生效 #515 [Bug]: 用 hexo-renderer-markdown-it，文章目录条目无链接包裹，无法跳转 #941](https://github.com/jerryc127/hexo-theme-butterfly/issues/941) 打开 hexo-renderer-markdown-it/index.js 文件，查看设置： 1234567891011hexo.config.markdown.anchors = Object.assign(&#123; level: 2, collisionSuffix: &#x27;&#x27;, permalink: false, // permalink: true, permalinkClass: &#x27;header-anchor&#x27;, permalinkSide: &#x27;left&#x27;, permalinkSymbol: &#x27;¶&#x27;, case: 0, separator: &#x27;-&#x27;&#125;, hexo.config.markdown.anchors); 没有需要改动的地方，找到 Hexo 配置文件，修改为： 1234markdown: anchors: level: 1 permalink: true 亲测有效。 ¶solution.2: markdown-it-named-headings 参考链接： Cannot render headings with ids? #40 按照各位网友的提示，可以使用插件 markdown-it-named-headings 来解决。 1npm install markdown-it-named-headings --save 添加一行语句在 markdown-it-named-headings/index.js 文件中： 1parser.use(require(&#x27;markdown-it-named-headings&#x27;)) 12345678910111213141516171819202122232425262728293031323334353637383940414243var kebabcase = require(&#x27;lodash.kebabcase&#x27;)var unidecode = require(&#x27;unidecode&#x27;)module.exports = function plugin (md, options) &#123; md.core.ruler.push(&#x27;named_headings&#x27;, namedHeadings.bind(null, md))&#125;function namedHeadings (md, state) &#123; var ids = &#123;&#125; state.tokens.forEach(function (token, i) &#123; if (token.type === &#x27;heading_open&#x27;) &#123; var text = md.renderer.render(state.tokens[i + 1].children, md.options) var id = kebabcase(unidecode(text)) var uniqId = uncollide(ids, id) ids[uniqId] = true setAttr(token, &#x27;id&#x27;, uniqId) &#125; &#125;)&#125;function uncollide (ids, id) &#123; if (!ids[id]) return id var i = 1 while (ids[id + &#x27;-&#x27; + i]) &#123; i++ &#125; return id + &#x27;-&#x27; + i&#125;function setAttr (token, attr, value, options) &#123; var idx = token.attrIndex(attr) if (idx === -1) &#123; token.attrPush([ attr, value ]) &#125; else if (options &amp;&amp; options.append) &#123; token.attrs[idx][1] = token.attrs[idx][1] + &#x27; &#x27; + value &#125; else &#123; token.attrs[idx][1] = value &#125;&#125;parser.use(require(&#x27;markdown-it-named-headings&#x27;)) 网友们反馈有效。","categories":[{"name":"高效工作","slug":"高效工作","permalink":"http://example.com/categories/%E9%AB%98%E6%95%88%E5%B7%A5%E4%BD%9C/"},{"name":"Hexo","slug":"高效工作/Hexo","permalink":"http://example.com/categories/%E9%AB%98%E6%95%88%E5%B7%A5%E4%BD%9C/Hexo/"}],"tags":[{"name":"work","slug":"work","permalink":"http://example.com/tags/work/"}]},{"title":"罗德里格斯旋转公式推导","date":"2023-01-11T13:24:42.000Z","path":"2023/01/11/罗德里格斯旋转公式推导/","text":"罗德里格斯旋转公式（Rodrigues' rotation formula）推导 转载： 博客园-wtyuan：罗德里格斯旋转公式（Rodrigues’ rotation formula）推导","categories":[{"name":"Mechanics","slug":"Mechanics","permalink":"http://example.com/categories/Mechanics/"},{"name":"姿态","slug":"Mechanics/姿态","permalink":"http://example.com/categories/Mechanics/%E5%A7%BF%E6%80%81/"}],"tags":[{"name":"Physics","slug":"Physics","permalink":"http://example.com/tags/Physics/"}]},{"title":"python-ERRORandWORMING","date":"2022-11-24T09:38:43.000Z","path":"2022/11/24/python-ERRORandWORMING/","text":"¶Error ¶No module named numpy 在输入 1import numpy 时, 出现错误. overflow - Error “Import Error: No module named numpy” on Windows ¶找出原因: 没有安装NumPy模块. ¶解决办法: 下载模块. 在终端输入 1pip install numpy ¶ValueError: check_hostname requires server_hostname ¶原因 在尝试下载NumPy模块时出现的报错, 和代理有关. 同时用如下的长篇错误: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100ERROR: Exception: Traceback (most recent call last): File \"c:\\users\\11905\\appdata\\local\\programs\\python\\python39\\lib\\site-packages\\pip\\_internal\\cli\\base_command.py\", line 180, in _main status = self.run(options, args) File \"c:\\users\\11905\\appdata\\local\\programs\\python\\python39\\lib\\site-packages\\pip\\_internal\\cli\\req_command.py\", line 205, in wrapper return func(self, options, args) File \"c:\\users\\11905\\appdata\\local\\programs\\python\\python39\\lib\\site-packages\\pip\\_internal\\commands\\install.py\", line 318, in run requirement_set = resolver.resolve( File \"c:\\users\\11905\\appdata\\local\\programs\\python\\python39\\lib\\site-packages\\pip\\_internal\\resolution\\resolvelib\\resolver.py\", line 127, in resolve result = self._result = resolver.resolve( File \"c:\\users\\11905\\appdata\\local\\programs\\python\\python39\\lib\\site-packages\\pip\\_vendor\\resolvelib\\resolvers.py\", line 473, in resolve state = resolution.resolve(requirements, max_rounds=max_rounds) File \"c:\\users\\11905\\appdata\\local\\programs\\python\\python39\\lib\\site-packages\\pip\\_vendor\\resolvelib\\resolvers.py\", line 341, in resolve name, crit = self._merge_into_criterion(r, parent=None) File \"c:\\users\\11905\\appdata\\local\\programs\\python\\python39\\lib\\site-packages\\pip\\_vendor\\resolvelib\\resolvers.py\", line 172, in _merge_into_criterion if not criterion.candidates: File \"c:\\users\\11905\\appdata\\local\\programs\\python\\python39\\lib\\site-packages\\pip\\_vendor\\resolvelib\\structs.py\", line 139, in __bool__ return bool(self._sequence) File \"c:\\users\\11905\\appdata\\local\\programs\\python\\python39\\lib\\site-packages\\pip\\_internal\\resolution\\resolvelib\\found_candidates.py\", line 143, in __bool__ return any(self) File \"c:\\users\\11905\\appdata\\local\\programs\\python\\python39\\lib\\site-packages\\pip\\_internal\\resolution\\resolvelib\\found_candidates.py\", line 129, in &lt;genexpr&gt; return (c for c in iterator if id(c) not in self._incompatible_ids) File \"c:\\users\\11905\\appdata\\local\\programs\\python\\python39\\lib\\site-packages\\pip\\_internal\\resolution\\resolvelib\\found_candidates.py\", line 30, in _iter_built for version, func in infos: File \"c:\\users\\11905\\appdata\\local\\programs\\python\\python39\\lib\\site-packages\\pip\\_internal\\resolution\\resolvelib\\factory.py\", line 269, in iter_index_candidate_infos result = self._finder.find_best_candidate( File \"c:\\users\\11905\\appdata\\local\\programs\\python\\python39\\lib\\site-packages\\pip\\_internal\\index\\package_finder.py\", line 879, in find_best_candidate candidates = self.find_all_candidates(project_name) File \"c:\\users\\11905\\appdata\\local\\programs\\python\\python39\\lib\\site-packages\\pip\\_internal\\index\\package_finder.py\", line 824, in find_all_candidates page_candidates = list(page_candidates_it) File \"c:\\users\\11905\\appdata\\local\\programs\\python\\python39\\lib\\site-packages\\pip\\_internal\\index\\sources.py\", line 134, in page_candidates yield from self._candidates_from_page(self._link) File \"c:\\users\\11905\\appdata\\local\\programs\\python\\python39\\lib\\site-packages\\pip\\_internal\\index\\package_finder.py\", line 783, in process_project_url html_page = self._link_collector.fetch_page(project_url) File \"c:\\users\\11905\\appdata\\local\\programs\\python\\python39\\lib\\site-packages\\pip\\_internal\\index\\collector.py\", line 512, in fetch_page return _get_html_page(location, session=self.session) File \"c:\\users\\11905\\appdata\\local\\programs\\python\\python39\\lib\\site-packages\\pip\\_internal\\index\\collector.py\", line 422, in _get_html_page resp = _get_html_response(url, session=session) File \"c:\\users\\11905\\appdata\\local\\programs\\python\\python39\\lib\\site-packages\\pip\\_internal\\index\\collector.py\", line 120, in _get_html_response resp = session.get( File \"c:\\users\\11905\\appdata\\local\\programs\\python\\python39\\lib\\site-packages\\pip\\_vendor\\requests\\sessions.py\", line 555, in get return self.request('GET', url, **kwargs) File \"c:\\users\\11905\\appdata\\local\\programs\\python\\python39\\lib\\site-packages\\pip\\_internal\\network\\session.py\", line 449, in request return super().request(method, url, *args, **kwargs) File \"c:\\users\\11905\\appdata\\local\\programs\\python\\python39\\lib\\site-packages\\pip\\_vendor\\requests\\sessions.py\", line 542, in request resp = self.send(prep, **send_kwargs) File \"c:\\users\\11905\\appdata\\local\\programs\\python\\python39\\lib\\site-packages\\pip\\_vendor\\requests\\sessions.py\", line 655, in send r = adapter.send(request, **kwargs) File \"c:\\users\\11905\\appdata\\local\\programs\\python\\python39\\lib\\site-packages\\pip\\_vendor\\cachecontrol\\adapter.py\", line 53, in send resp = super(CacheControlAdapter, self).send(request, **kw) File \"c:\\users\\11905\\appdata\\local\\programs\\python\\python39\\lib\\site-packages\\pip\\_vendor\\requests\\adapters.py\", line 439, in send resp = conn.urlopen( File \"c:\\users\\11905\\appdata\\local\\programs\\python\\python39\\lib\\site-packages\\pip\\_vendor\\urllib3\\connectionpool.py\", line 696, in urlopen self._prepare_proxy(conn) File \"c:\\users\\11905\\appdata\\local\\programs\\python\\python39\\lib\\site-packages\\pip\\_vendor\\urllib3\\connectionpool.py\", line 964, in _prepare_proxy conn.connect() File \"c:\\users\\11905\\appdata\\local\\programs\\python\\python39\\lib\\site-packages\\pip\\_vendor\\urllib3\\connection.py\", line 359, in connect conn = self._connect_tls_proxy(hostname, conn) File \"c:\\users\\11905\\appdata\\local\\programs\\python\\python39\\lib\\site-packages\\pip\\_vendor\\urllib3\\connection.p return ssl_wrap_socket( File \"c:\\users\\11905\\appdata\\local\\programs\\python\\python39\\lib\\site-packages\\pip\\_vendor\\urllib3\\util\\ssl_.py\", line 432, in ssl_wrap_socket ssl_sock = _ssl_wrap_socket_impl(sock, context, tls_in_tls) File \"c:\\users\\11905\\appdata\\local\\programs\\python\\python39\\lib\\site-packages\\pip\\_vendor\\urllib3\\util\\ssl_.py\", line 474, in _ssl_wrap_socket_impl return ssl_context.wrap_socket(sock) File \"c:\\users\\11905\\appdata\\local\\programs\\python\\python39\\lib\\ssl.py\", line 500, in wrap_socket return self.sslsocket_class._create( File \"c:\\users\\11905\\appdata\\local\\programs\\python\\python39\\lib\\ssl.py\", line 997, in _create raise ValueError(\"check_hostname requires server_hostname\")ValueError: check_hostname requires server_hostname ¶解决办法 把代理关了","categories":[{"name":"Language","slug":"Language","permalink":"http://example.com/categories/Language/"},{"name":"python","slug":"Language/python","permalink":"http://example.com/categories/Language/python/"}],"tags":[{"name":"Language","slug":"Language","permalink":"http://example.com/tags/Language/"}]},{"title":"Windows 下 FRP 内网穿透计划","date":"2022-09-23T09:28:06.000Z","path":"2022/09/23/Windows-下-FPR-内网穿透计划/","text":"¶为什么使用 FRP 实验室里规定 21: 25 就可以走了, 但是我是自愿加班的, 操场 23:00 关闭, 但是人要 12 点睡, 就意味着还有一个小时左右的时间, 但是操场离寝室近离实验室远, 冬天又太冷了… 所以一般就直接回宿舍了. (其实就是懒狗想要早点下班) 实验室有自己的局域网, 寝室里的电脑连的是校园网, 这个时候 Windows 自带的远程桌面就派不上用场了. 但是有时候坐在寝室里突然间灵光一闪要用实验室的电脑, 这个时候要是碰不到电脑的话, 这个偶然涌出的想法可能就要消失了! 所以能够让我随时随地用到实验室的电脑是一件必须的事情, 于是开始网上冲浪, 找出在寝室访问实验室电脑的方法. ¶FRP 原理 附上: FPR文档 frp 主要由 客户端(frpc) 和 服务端(frps) 组成，服务端通常部署在具有公网 IP 的机器上，客户端通常部署在需要穿透的内网服务所在的机器上。 内网服务由于没有公网 IP，不能被非局域网内的其他用户访问。 用户通过访问服务端的 frps，由 frp 负责根据请求的端口或其他信息将请求路由到对应的内网机器，从而实现通信。 ¶云服务器 云服务器的作用, 分享链接: 买了一台云服务器到底能干什么？ - Logic的回答 - 知乎 在这条回答下有人评论: 如果只是为了远程，Sakura frp足够了，保险可以加个花生棒。免费 这里已经为了 FRP 看了很多资料了, 决定死磕 FRP , 有时间再去了解 Sakura Frp. 附上 Sakura Frp 的链接: https://www.natfrp.com/ ¶如何知道自己的电脑是什么框架 ¶Windows 在命令行中输入 echO %PROCESSOR_ARCHITECTURE% 输出如下值之一: x86, AMD64, ARM64 ¶Linux 在命令行中输入 uname -m, 直接显示Linux 系统架构 我的虚拟机为 x86_64 架构. 更多方法可查阅博客: Linux 要如何查看系统架构 ¶如何判断自己的电脑是否有公网 ip 通过这个网站, ip 地址查询网站: https://www.ip138.com/ 打开命令行, 输入指令 tracert + 搜到的ip地址 1tracert 111.40.58.238 追踪公网IP，通过网站得到的公网 IP是 111.40.58.238, 而实际上我的 ip 地址是 192.168.1.118 (192.168.1.1 是路由). 第一行为节跃点数, 所以中间肯定有其它的节点也就是路由，只要跃点超过一个就说明电脑就没有获得公网IP。这里, 显然我的电脑没有公网 ip. 假如是家庭宽带可以打电话向运营商的人工客服要, 直接说装监控需要分配公网IP. 但我这里是学校 WiFi, 这一条路是走不通的. 参考: 作者: 云爻斋-出处：bilibili ¶准备工作 ¶设备 移动机器: 不需要下载任何软件 实验室机器(客户端frpc): 系统: Windows 10 专业版 云服务器(服务端frps): 具有公网 IP 的中转服务器, 两个内网机械是无法相连的, 公网服务器的作用是中转. 客户端先连接中转服务器, 经由中转服务器与内网服务器相连, 起到内网穿透的效果. 参考教程: windows下基于frp的内网穿透部署 - 进化的monkey的文章 - 知乎 内网穿透 frp 配置 - Yuqi’s blog ¶购买云服务器 这里参考其他博主, 选择了阿里云 ECS . 附购买指南链接: 阿里云开发者社区 - 阿里云学生机购买指南(用途和优势)(阿里云学生机购买指南(用途和优势) **飞天加速计划计划(原云翼计划)是阿里云校园扶持计划，24岁以下或拥有学信网认证信息即可享优惠产品、创业扶持等多项权益哦！包括：专属云服务器产品优惠、校园产品使用攻略等。 平均一个月9.5元，一天只需要0.3元。一年只需114元。 步骤 注册阿里云账号, 阿里云: https://www.aliyun.com/?spm=5176.authc-home.top-nav.dlogo.63834babxeYHR1 进行学生认证,建议使用支付宝认证, 不需要等待, 两分钟搞定! nice ! 阿里云学生机官网地址：https://promotion.aliyun.com/ntms/act/campus2018.html. 尝试使用阿里云 RCS 云服务器, 新手指引-实例-云服务器ECS-阿里云: https://help.aliyun.com/document_detail/25422.html 选型最佳实践: https://help.aliyun.com/document_detail/58291.html?spm=a2c4g.11186623.0.0.1d46637fqT7uVC 现在选择了 ECS 的学生免费领取活动, 做一个实验, 再答一套题就可以领取. 在选择操作系统的时候, 会发现下拉表单中的操作系统没有一个符合 Windows 10 专业版. 这里要说 Windows server 操作系统. Windows Server是Microsoft专门创建用于服务器的一系列操作系统。服务器是功能非常强大的计算机，旨在持续运行并为其他计算机提供资源。这意味着在几乎所有情况下，Windows Server仅在业务设置中使用。Server主要面向服务器，是一个服务器操作系统. Windows的消费者版本面向个人用户. 参考资料:windows server和windows的区别 - 国家一级保护废物的文章 - 知乎 搭配 ECS 后控制台里会出现一个实例 参考链接:CSDN - 1.学生版阿里云简单配置和win7、win10专业版及win10家庭版的远程桌面的配置详解: https://blog.csdn.net/qq_41903105/article/details/85224145 Windows 系统选择了‘2016 数据中心版…’可行 重置密码 登录名: administrator 密码设置为: Lyh#2022 这里会给手机发一个验证码 改完之后重启实例 阿里云提供的示例中的一些基本信息 因为刚开始不懂, 以为云主机的操作系统要和电脑操作系统一致, 现在知道完全是我多虑了… 暂时用 Windows 系统, 再换用 Linux 系统. (都云服务器了, 当然首选 Linux 啊! ) ¶连接云服务器 使用阿里云提供的远程连接方式. workbench 远程连接: 通过网页可以对ECS实例进行远程控制，支持复制粘贴文本，支持多操作系统用户登录同一台实例。 VNC远程连接: VNC远程连接是一种使用RFB协议的屏幕画面分享及远程操作工具，不需要单独为实例设置网络规则即可使用，但其连接质量较差，仅推荐作为临时连接方案使用。 发送命令（云助手）: 发送远程命令可以帮助您在实例内部快速执行命令，即无需远程连接登录实例，即可完成查看硬盘空间、安装软件、启动停止服务等操作。 使用workbench 远程连接方式: 选择密码认证, 输入密码即可. (更换系统为 Linux 系统) 选用 Alibaba Cloud Linux 3.2104 LTS 64 位. 登录上去为一个控制台 输入指令 ls- l 返回 total 0 信息, 刚登录是没有文件的. 在命令行中输入 ssh 用户名@@xxx.xx.xx.xx, 此处xxx.xx.xx.xx 为 云产品资源 提供的 弹性IP）下面的两张图上边的是阿里云提供的实例中的图, 下面的是我免费领取的 ecs 实例的图. 好像是按量计费的产品才有弹性公网 IP, 包年包月的就没有. 1ssh root@101.133.151.69 //阿里云示例 手动输入 yes 输入密码, 提示:输入密码时界面是没有反应的，输入完毕直接回车即可，不要误以为出问题了。 成功之后应该是这样的: 参考教程: 【bilibili: 阿里云-云服务器ECS20-连接云主机】 使用心得: 学生机注册使用体验有点差, 用开始支付宝认证还挺方便的, 后来还要在手机上下载阿里云app和人脸识别验证这一点我不是很喜欢, 个人不喜欢在手机和电脑上安装软件, 也不喜欢给一个新的 app 身份验证. 目前两台电脑已经不在同一个局域网下, 在远程桌面下输入阿里云提供的公网 ip , 可以找到我的Windows账户. 现在仍然有问题, 当我像往常一样输入我的 Windows 密码时提示我: 之前用于连接到 xxx.xxx.xxx.xxx 的凭证无法工作, 请输入新凭证. ¶下载 下载地址: https://github.com/fatedier/frp/releases 根据服务器、内网主机的系统框架，分别下载 frp. 客户端选择的是第一个“frp_0.44.0_darwin_amd64.tar.gz” 版本 服务器端为 x86_64 架构, 选择 “frp_0.44.0_linux_386.tar.gz” 版本 ¶服务器端 使用 url 指令安装 12curl -# -LJOhttps://github.com/fatedier/frp/releases/download/v0.44.0/frp_0.44.0_linux_386.tar.gz 没有 curl也可以使用 wget 安装 1wgethttps://github.com/fatedier/frp/releases/download/v0.44.0/frp_0.44.0_linux_386.tar.gz 以上两种方法我均失败了(…) 成功方法: 使用 SSH 传输. 先在本地下载好需要的安装包, 复制路径, 然后再到相应路径下去上传(这里我没有注意到 cmd 默认在用户目录下开始, 而我的压缩包并不在 users 下面), 先一路 cd 出来, 然后输入命令: 1234scp /本地文件路径/test.txt root@123.123.123.123:/服务器文件路径/// 我的相应命令C:\\&gt;scp /Document\\GoogleDocuments\\frp_0.44.0_linux_386.tar.gz root@39.101.75.147:/work/frp/// 表示将该 frp 文件上传到 Linux 机器的 /work/frp/ 文件夹里 这样就成功了! 然后到云服务器这里查看, 注意: 云服务器中的默认路径并不是根目录, 用 pwd 指令查看当前路径, 发现在 /root 中 再一路 cd 出去, 可以看到上传上去的 frp 压缩包文件了. 用 tar -zxvf 指令解压 用 vim frp.ini 编辑 frp.ini 文件 用 :wq 退出编辑 输入 ./frps -c frps.ini 启动服务器端, 收到如下信息则成功 1232022/10/02 19:33:21 [I] [root.go:209] frps uses config file: frps.ini2022/10/02 19:33:21 [I] [service.go:194] frps tcp listen on 0.0.0.0:70002022/10/02 19:33:21 [I] [root.go:218] frps started successfully 教程: 内网穿透FRP详细教程 Linux上传下载文件的几种方式 - 新睿云服务器的文章 - 知乎 教你 2 种从 Linux 终端下载文件的方法 阿里云开发者社区 - Linux服务器怎样上传下载文件 从Linux服务器下载文件到本地or上传文件到Linux服务器的方法 csdn - linux 新建文件夹命令 ¶客户端 直接在 GitHub 下载 ADM64 架构的文件即可. ¶配置步骤 下载下来的 fpr 其实就是个文件夹, 里面的文件如下所示: 注意：服务器端使用的版本和内网主机使用的要一致，不然容易出问题 ¶服务器端 frps 这里只需要修改 “frps.ini” 文件即可. 在具有公网 IP 的机器上部署 frps，修改 frps.ini 文件，这里使用了最简化的配置，设置了 frp 服务器用户接收客户端连接的端口： 1234567[common]bind_port = 7000 # frp服务的端口号，可以自己定dashboard_port = 7500 # frp的web界面的端口号dashboard_user = user # web界面的登陆账户，自己修改dashboard_pwd = pass # web界面的登陆密码，自己修改authentication_method = tokentoken = Lyh@2022 # frp客户端连接时的密码，自己修改 注意: 实际使用要把注释删掉 ¶客户端 本地机器下载如图的版本, 注意要先点击 “查看全部” 才会出现. 客户端配置: 12345678910[common]// xx.xx.xx 是公网ipserver_addr = xx.xx.xxserver_port = 7000[ssh]type = tcplocal_ip = 127.0.0.1local_port = 22remote_port = 6000 服务器端的i打开相应的端口, 不然会出现timeout的报错 打开方法参考阿里云官方文档: https://www.fzxm.com/help/20210430095425001.html 在 PowerShell 中启动客户端, 发现有报错login to server failed (在 cmd 中指令没用) 查找原因, 网上的说法是学校局域网特殊的问题, 解决: 在客户端原来的[common]配置中加入tls_enable = true即可. 事实上, 我加了, 还是没有用, 连自己的热点也报这个错, 继续… 参考文献: https://www.bilibili.com/read/cv16500867 https://geomatlab.com/frp-windows-rdp/#toc-head-9 https://vilark.com/14.html 换通过 Bush 启动, 给出了更加详细的报错 字面意思是“因为目标机器主动拒绝它，所以无法进行连接。”, 这种情况应该是机器设备的配置出了问题, 而不是 FRP 的问题. 参考资料: https://www.suajin.com/detail/721 ¶替代项目 开源项目openp2p，据说不需要公网服务器，假如只用来远程访问的话，用这个工具比做内网穿透方便多了！！！ 我的免费 ECS 过期后可以尝试！！nice！ ¶10.2 现场保护 Alliot’s blog-群晖入门到进阶系列（二）：DDNS与端口转发 csdn-借助ecs的公网ip将自己家里的Windows做个内外穿透【外网可以访问的】–frp【远程连接Windows电脑】 买了一台云服务器到底能干什么？ - Logic的回答 - 知乎 windows下基于frp的内网穿透部署 - 进化的monkey的文章 - 知乎 腾讯云开发者社区-frp配置内网穿透教程（超详细） csdn-跨局域网远程连接神器——frp内网穿透 超详细frp配置实现绕过防火墙内网渗透 dial tcp IP:PORT: i/o timeout #2905 【阿里云服务器ECS建站教程全套（适合0基础初学者），小白轻松拥有个人网站！| 保姆级教程 使用frp进行内网穿透入门 Windows命令窗口输入命令报错不是内部或外部命令，也不是可运行的程序 或批处理文件 内网穿透FRP详细教程 跨局域网远程连接神器——frp内网穿透 frp内网穿透实现文件共享祥细教程 frp文档-通过 SSH 访问内网机器 博客园-局域网两个不同网段互相访问 ¶3.20 现场保护 login to server failed: dial tcp 182.243.33.96:7000: i/o timeout #3058 login to server failed: dial tcp {IP:PORT}: i/o timeout #2843 Why am I getting “Connection refused”? Add a firewall exception to a port frp内网穿透，rdp远程连接Windows计算机 Configuration to disable system proxy #2012 [W] [service.go:102] login to server failed: dial tcp 127.0.0.1:7000: connect: connection refused #2021 再见TeamViewer，5分钟自建急速远程桌面服务器","categories":[{"name":"高效工作","slug":"高效工作","permalink":"http://example.com/categories/%E9%AB%98%E6%95%88%E5%B7%A5%E4%BD%9C/"}],"tags":[{"name":"work","slug":"work","permalink":"http://example.com/tags/work/"},{"name":"Frp","slug":"Frp","permalink":"http://example.com/tags/Frp/"},{"name":"云服务器","slug":"云服务器","permalink":"http://example.com/tags/%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8/"}]},{"title":"嵌入式原理及应用(05)-MCS51指令系统的寻址方式","date":"2022-09-15T02:39:00.000Z","path":"2022/09/15/嵌入式原理及应用-05-MCS51指令系统的寻址方式/","text":"寻址方式是指寻找、确定参与操作的数据的地址的方式，一般来说, 寻址方式越多, 单片机的功能就越强, 灵活性就越大, 指令系统就越复杂. 寻址方式所要解决的主要问题就是如何在整个存储器和寄存器的寻址空间内, 灵活方便、快速的找到指定的操作数。 ¶寄存器寻址 可用于访问选定寄存器区的8个工作寄存器R0~R7、A、B、DPTR、Cy等。 1MOV A,R1 ¶直接寻址方式 指令中的第二操作数为立即数。51指令中的立即数应冠以前缀’#'，且若立即数的首位为A~F，前面还要加零。 12MOV A,#40Hmov A,#0A5H ¶直接寻址 指令中直接给出操作数所在的单元地址, 该单元地址中的内容就是操作数, 直接操作数单元地址用 ‘direct’ 表示. 直接寻址方式是对片内所有特殊功能寄存器访问的唯一方式. 12MOV A, #40H; 将内部 RAM 40H 单元的内容送到 AMOV 42H, 62H; 将内部 RAM 62H 单元内容转给 42H 单元中 访问 SFR 可用: 寄存器寻址 直接寻址 ¶寄存器间接寻址 在寄存器中存放的是操作数的地址, 从寄存器中找到操作数的地址, 再按照该地址找到操作数. 用于访问内部RAM和外部数据区，包括52系列单片机的高128字节RAM，只有R0,R1可以作为间址寄存器。 在寄存器间接寻址方式中应在寄存器前加 ‘@’ 12345MOV R0,#40H; 访问低128字节RAMMOV A,@R0; 先从R0中找到源操作数所在地址 40H 然后把 40H 中的内容传给 AMOV R0,#90H; 访问高128字节RAMMOV A,@R0 ¶基址寄存器加变址寄存器间接寻址 基址寄存器加变址寄存器间接寻址以 DPTR 或者 PC 作为基址寄存器, 以累加器 A 作为变址寄存器, 并以两者内容相加形成新的16位地作为目的地址进行寻址. 12345MOVC A, @A+DPTR; DPTR: 数据指针MOVC A, @A+PC; PC: 程序指针;上两条适用于读程序存储器中的固定数据, 例如按照固定的, 一定顺序排列的表格参数JMP @A+DPTR; 散转指令, A 中的内容为程序运行后的动态结果, 可根据 A 的内容不同来实现向不同程序入口的跳转. DPTR 是 16 位寄存器, 只有 DPRT 可以传入 16 位数, 常用于存储地址位 MCS-51 地址位为 16 位的原因: 有 16 根地址总线 ¶位寻址方式 内部 RAM 和特殊功能寄存器中的可寻址位 位寻址是指对内部 RAM 和特殊功能寄存器具有位寻址功能的某位内容进行置 1 和清 0 操作. 位地址一般以直接的位地址给出, 符号为 ‘bit’. 12MOV C, bitMOV C, 40H; 把位地址为 40H 的位值 0 或 1 送给进位位 C. ¶相对寻址方式 相对寻址方式是为了解决程序跳转而专门设置的, 为转移指令所用. 程序跳转到目的地址: 目的地址 = 跳转指令所在地址(PC值) + 转移字节数(跳转指令下一条指令的首地址) + 偏移量 rel 相对偏移 rel 是单字节的带符号的 8 位二进制数的补码数. 它所能表示的数字范围是 -128 ~ + 127. 在实际编写程序时, 只需要在转移指令中直接写上要转向的地址标号即可 12345SJMP rel; 跳转指令的 PC 值加 2 (因为 SJMP rel 指令占用两个字节数) ; 再加上相对偏移量 rel 后的目的地址, 其中 rel 为 8 位带符号的补码.SJMP LOOP; 直接写上转移标号","categories":[{"name":"Electricity","slug":"Electricity","permalink":"http://example.com/categories/Electricity/"},{"name":"硬件","slug":"Electricity/硬件","permalink":"http://example.com/categories/Electricity/%E7%A1%AC%E4%BB%B6/"}],"tags":[{"name":"专业课","slug":"专业课","permalink":"http://example.com/tags/%E4%B8%93%E4%B8%9A%E8%AF%BE/"}]},{"title":"嵌入式原理及应用(04)-MCS51的指令系统","date":"2022-09-15T02:38:10.000Z","path":"2022/09/15/嵌入式原理及应用-04-MCS51的指令系统/","text":"¶概述 51共有指令111条 字节 单字节指令49条 双字节指令45条 三字节指令17条 执行周期 单机器周期指令64条 双机器周期指令45条 4 机器周期指令 2 条 ¶汇编指令的基本结构 1Loop1: mov a, #0ffh; 累计器A赋值为ff LOOP1: mov a , #0ffh; 累计器A赋值为ff [标号]: 操作码助记符 [第1操作数] , [第2操作数]; 注释 [标号] ：表示该指令所在的符号地址，一般由字母和数字组成，第一位为字母，其余位为字母、数字任选。 操作码助记符 、[第1操作数] 和 [第2操作数]：指令的核心部分。对于某些指令可能不存在完整的两个操作数。 注释：是由用户加入的文本，对汇编程序不起任何作用，只是方便阅读。 第1操作数又称目的操作数，第2操作数又称源操作数 汇编语言可以直接对硬件进行操作, 效率高于高级语言 汇编语言不区分大小写 汇编语言用分号 ‘;’ 进行注释 CPU只能执行机器语言（由8位二进制代码组成，分为1字节、2字节、3字节）。所有的汇编程序都要先转化为机械码 123RET &lt;=&gt;22HMOV A,#0fh &lt;=&gt;74H 0FHMOV 74H,#0BH &lt;=&gt;75H 74H 0BH [此处插入一个关于指令和对应功能机械码的表格, 课本p62表3-2] 参考文献: Microsoft Word - 新1-3.doc(模块三 80C51 的指令系统和程序设计) ¶数据传送类 指令介绍中符号的说明： Rn：当前工作寄存器区中R0~R7 Ri：当前工作寄存器区中的R0,R1 Direct：直接地址 #data：指令中的常数（8位或16位） Dptr：数据指针 @：间接寻址前缀 (X) ：x中的内容（20h） ((x))：在间接寻址中，由间址寄存器寻址的单元中的内容 ((R0))，若R0=20H，则((R0))表示（20H） ¶MOV 1234567Mov a, Rn; 以累加器为目的Mov Rn, #0A0h; 以Rn为目的操作数Mov 40H, @Ri；以直接地址为目的操作数Mov @Ri, #0B0h；以寄存器间接地址为目的操作数Mov dptr, #2000h; 把 16 位立即数送入 DPTR , 用来设置外部存储器的地址指针MOV Rn, direct; 将源操作数中的内容送入到当前工作寄存器 R0 ~ R7 中的某一个寄存器 所有 MOV 类指令, 累加器 A 是一个非常重要的 8 位寄存器, CPU 对它具有其他存储器所没有的操作指令 ¶MOVX /访问外部数据存储器 A与外部数据存储器传送 1234Movx a,@dptrMovx a,@RiMovx @dptr,aMovx @Ri,a ¶MOVC /访问外部程序存储器 MOVC 用于访问外部程序存储器 表格存放在外部程序存储器中 12; 查表指令Movc a,@a+pc（单字节） 若程序中这指令所在的地址为1000h，这是一条单字节指令。CPU执行此条指令时，pc=1001, 假定此时a=30h。那么，程序的执行结果，是将程序存储器1031H中内容，读入a中。 这条指令的优点是不改变特殊功能寄存器及 PC 的状态, 根据 A 中的内容就可以取出表格中的常数, 缺点是表格只能存放在该查表指令所在地址的 +256 个单元内 只能访问该指令后面256单元 1234567891011121314; 例: 求 0~9 的平方 ORG 0000H LJMP A1 ORG 0080HA1: NOP NOP MOV SP,#60H MOV DPTR,#2000H MOV A,#03H；将0~9之内任意一个数赋值给A。 MOVC A,@A+DPTRA2: SJMP A2 ORG 2000H DB 00h,01h,04h,09h,10h,19h,24h,31h,40h,51h END 执行 MOVC 指令时, 伴随单片机的 引脚信号同时有效 ¶push / pop 12345(sp)=60h,(a)=30h,(b)=70hPush a ;(sp)+1=61h=&gt;sp (a)=&gt;61hPush b ; (sp)+1=62h=&gt;sp (b)=&gt;62hPop b ; (sp)=&gt;b (sp)-1=&gt;sp =61hPop a ; (sp)=&gt;a (sp)-1=&gt;sp =60h PUSH: 先 +1 , 后入栈 POP: 先出栈, 后 -1 ¶XCH /字节交换指令 将累加器内容与源操作数内容相互交换 12345Xch a,RnXch a,40h（直接地址）Xch a,@RiXch a,R7; 若a=55h;R7=66h，指令执行结果a=66h,R7=55h ¶XCHD /半字节交换 累加器 A 的低四位与内部 RAM 低四位交换. 只变低四位, 高四位不变. 123Xchd a,@R0; 若a=59h,R0=60h,(60h)=3eh,执行结果a=5eh,(60h)=39h; 59H = 0101 1001, (60H) = 3EH = 0011 1110 Data 6, Data 7 同时有进位或同时没有进位, OV = 0 ¶算数操作类 ¶ADD /加法指令 共有 4 条加法指令 1234ADD A, RnADD A, directADD A, @RiADD A, #data 如果位7有进位输出，则置“1”Cy位，否则清零； 如果位3有进位输出，则置“1”Ac位，否则清零； 如果位6有进位而位7没有进位，或者位7有进位而位6没有，则置位溢出标志位OV置\"1\"；否则对溢出标志位清零。(6 和 7 同时有进位或者都没有进位时 OV = 0) 溢出标志位 OV 的状态, 只有在进行带符号数的加法运算时才有意义 例: 53H + FCH, (A) = 4FH, Cy = 1, Ac = 0, OV = 0, P = 1 85H + AFH, (A) = 34H, Cy = 1, Ac = 1, OV = 1, P = 1 ¶ADDC /带进位加法指令 通常将进位标识符 Cy 简称为 C, ADDC 则意为带上进位标志位的加法指令. 带进位标志位加法指令的特点是 Cy 参加运算, 是三个数相加 共有 4 条加法指令 1234ADDC A, RnADDC A, directADDC A, @RiADDC A, #data 例: (A) = 85H, (20H) = FFH, Cy = 1 12ADDC A, 20H; (A) = 85H, Cy = 1, Ac = 1, OV = 0, P = 1 ¶INC /加一指令","categories":[{"name":"Electricity","slug":"Electricity","permalink":"http://example.com/categories/Electricity/"},{"name":"硬件","slug":"Electricity/硬件","permalink":"http://example.com/categories/Electricity/%E7%A1%AC%E4%BB%B6/"}],"tags":[{"name":"专业课","slug":"专业课","permalink":"http://example.com/tags/%E4%B8%93%E4%B8%9A%E8%AF%BE/"}]},{"title":"单片机的硬件结构","date":"2022-09-14T08:15:04.000Z","path":"2022/09/14/单片机的硬件结构/","text":"¶冯·诺依曼结构 参考文献： 知乎-三分钟带你了解冯.诺依曼结构 维基百科-冯·诺伊曼结构 ¶哈佛结构和冯·诺依曼结构的辨析 参考文献：知乎-MCS-51 单片机的硬件结构 ¶算数逻辑运算单元 ALU 参考文献: 维基百科-算术逻辑单元 ¶51单片机中的342个特殊功能寄存器","categories":[{"name":"Electricity","slug":"Electricity","permalink":"http://example.com/categories/Electricity/"},{"name":"硬件","slug":"Electricity/硬件","permalink":"http://example.com/categories/Electricity/%E7%A1%AC%E4%BB%B6/"}],"tags":[]},{"title":"中学数学-03组合数公式","date":"2022-09-08T10:39:46.000Z","path":"2022/09/08/中学数学-03组合数公式/","text":"¶组合数公式性质: prove: 综上:","categories":[{"name":"Math","slug":"Math","permalink":"http://example.com/categories/Math/"},{"name":"中学数学","slug":"Math/中学数学","permalink":"http://example.com/categories/Math/%E4%B8%AD%E5%AD%A6%E6%95%B0%E5%AD%A6/"}],"tags":[{"name":"Math","slug":"Math","permalink":"http://example.com/tags/Math/"}]},{"title":"中学数学-02前n项相加","date":"2022-09-06T10:51:14.000Z","path":"2022/09/06/中学数学-02前n项相加/","text":"¶前 n 项相加 令: 倒序排列则为: 相加得: 故: ¶前 n 项的平方相加 ¶利用立方 已知: , 写出递推规律: 累加, 得: 故: 综上: ¶用递推关系求解 设数列 设 的一阶差数列为: 设 的二阶差数列为: 设 的三阶差数列为: 可设: 已知: 代入到上式中解出待定系数为: 故: 综上: ¶利用图形的方法求解 有三种表示方式: 综上: ¶扩展: 求前 n 项立方和 与 ‘利用立方求平方和的方法类似’ 同理可得: ¶扩展: 奇数项平方和公式 由上述平方和公式可得偶数项平方和公式为: 为偶数 所以奇数项平方和公式为: 为奇数 参考文献: 知乎-前n项平方和公式怎么推导？ - miniEthan的回答","categories":[{"name":"Math","slug":"Math","permalink":"http://example.com/categories/Math/"},{"name":"中学数学","slug":"Math/中学数学","permalink":"http://example.com/categories/Math/%E4%B8%AD%E5%AD%A6%E6%95%B0%E5%AD%A6/"}],"tags":[{"name":"Math","slug":"Math","permalink":"http://example.com/tags/Math/"}]},{"title":"中学数学-01解一元三次方程","date":"2022-09-05T13:49:53.000Z","path":"2022/09/05/中学数学-01解一元三次方程/","text":"¶步骤 一元三次方程: ） 先考虑将方程变形成 其中 ，， ； 将二次项消去, 得到: 然后，令 于是上面的方程可以变形成为 整理可得 ， 其中 设实根 ， 将方程两边同时立方，得到 和 就是方程 两个根, 解出一元二次方程即可得到 和 . 注意开立方是在复数域上开立方, 能够得到实根和复根. 由 的值迭代回去得到 的值, 再由 的值即可得到原一元三次方程的三个根. ¶证明 一元三次方程可以采用卡尔丹公式和盛金求根公式来计算。下面用最基础的代数方法来理解卡尔丹公式怎么来的。 一元三次方程 ） 1、为了解最初的方程，可以先考虑将方程变形成 其中 ，， 2、这个形式可以进一步化简。回顾一元二次方程的求根公式，采用配方法，将其变成和的平方的形式然后开方即可得到求根公式，这里最高次是3次，所以考虑配立方。 将 和1中的式子比较发现，可以把 并入和的立方里面。于是1中的方程可以成 然后，令 于是上面的方程可以变形成为 ，其中 整理可得 ， 其中 故而可以得到一个结论，所有的一元三次方程都可以化成上面那样的简单形式，因此只要找到 这个方程的解法，就能够解出所有的一元三次方程了； 3、 的解法 关于这个方程的解法，首先我们知道，三次函数的值域是R，因此这个三次方程一定至少有一个实根。 不妨设这个实根 得到一个新的方程，将这个方程两边同时立方，得到 显然这两个方程可以是同一个方程。比较系数，得到方程组 （ 根据一元二次方程的韦达定理，不难发现A和B就是方程 两个根。 因此不难解出 这样，可以用得到的A和B的值求出: 从而得到原方程的根。 复数域的开根号: 知欧拉公式: , 令: 其中 . 则由欧拉公式，可知 然后用倍角公式求取开根号后的值: 转载原文链接: 如何求一元三次方程 - 龍陽桑的文章 - 知乎 ¶例题 1. 解一元三次方程 将二次项消去, 得到: 原方程等于 令 上式等于: 解得: , 则: 解毕. 2. 解一元三次方程 原方程已没有二次项, 令 将方程式: 与原一元三次方程对比, 得到: 则 解毕.","categories":[{"name":"Math","slug":"Math","permalink":"http://example.com/categories/Math/"},{"name":"中学数学","slug":"Math/中学数学","permalink":"http://example.com/categories/Math/%E4%B8%AD%E5%AD%A6%E6%95%B0%E5%AD%A6/"}],"tags":[{"name":"Math","slug":"Math","permalink":"http://example.com/tags/Math/"}]},{"title":"概率论(99)-一些常用结论的推导","date":"2022-09-04T10:04:05.000Z","path":"2022/09/04/概率论-99一些常用结论的推导/","text":"¶e的-x的平方的积分: ¶二重积分 首先我们知道积分符号不影响积分的值，故： 紧接着转为二重积分： 上式转为极坐标更容易求解： 又因为 ，则 ，故： ¶利用正态分布结论 首先列出正态分布的表达式： 通过观察所求函数和正态分布表达式，我们可以令 ， (标准正态分布)，得到如下表达式： 正态分布在 到 的积分为1，故： 最后得出结论: 推广: 参考: 知乎-求e的-x的平方的积分的两种解法 ¶k的阶乘分之lambda 的k次方相加: ¶利用数列函数 设: 则: 故: 综上: ¶利用泰勒级数展开式 观察该式, 对比函数 对 的泰勒展开式: 故令 : ¶二项式分布的平均值: 设: 书写注意验证: 看上角标和下角标之和是否相等","categories":[{"name":"Math","slug":"Math","permalink":"http://example.com/categories/Math/"},{"name":"概率论","slug":"Math/概率论","permalink":"http://example.com/categories/Math/%E6%A6%82%E7%8E%87%E8%AE%BA/"}],"tags":[{"name":"Math","slug":"Math","permalink":"http://example.com/tags/Math/"}]},{"title":"嵌入式原理及应用(03)-MCS-51 的存储器结构","date":"2022-08-29T09:06:30.000Z","path":"2022/08/29/嵌入式原理及应用-03-MCS-51-的存储器结构/","text":"程序存储器地址为 16 位二进制数(4 位 16进制数) 数据存储器的片内地址为 2 位 16 进制数, 片外地址为 4 位 16 进制数. ¶程序存储器 单片机的分为数据存储器和程序存储器。单片机内部的存储器称为片内存储器，片外扩展的存储器成为片外存储器。比如8031内部有数据存储器而没有程序存储器，所以它一般要外接一块程序存储芯片，内部的数据存储器叫做9031的片内存储器，外部扩展的存储芯片叫做片外存储器。 参考: CSDN-单片机的片内存储器 片外存储器的内和外是相对于什么啊？ 片内传送数据用 MOV 片外传送数据用 MOVX 存储器中存放的实际上是由用户程序形成的二进制码（机器码），该存储器必须具有非易失性。 1move A ; 将 A 写入, 要将 A 先转化为机械码 程序存储器中存放程序和表格, 最多外扩64k. 由程序计数器（PC）控制程序的执行，PC中存放的是将要执行的下一条指令的地址，是由单片机内部硬件自动生成的，且自动加一. 单片机的中断源 中断入口地址 外部中断0（INT0） 0003H 定时器0（T0） 000BH 外部中断1（INT1） 0013H 定时器1（T1） 001BH 串行口 0023H 由于外部中断0 的中断服务程序入口地址为 0003H , 为使主程序不与外部中断0 的中断服务程序产生冲突, 一般在 0000H 单元内存放一条跳转指令, 转向主程序的入口地址. 由于程序存储器的起始部分具有特殊意义，在编制程序时主程序中最好有跳转指令，在中断程序中也要有跳转指令。 ¶内部数据存储器 MCS51内部数据存储器（RAM）共有 128 个字节，地址 00H~7FH 。51对内部数据存储器有丰富的操作指令。 ¶特殊功能寄存器（SFR） SFR共 21 个，存在于单片机RAM单元中，地址范围 80H~FFH 。 低 128 字节的 RAM 的单元地址为数据寄存器, 高 128 字节的 RAM 单元地址为特殊功能寄存器区. A是特殊功能寄存器 PC不是特殊功能寄存器 特殊功能寄存器反映了MCS51的状态，实际上是MCS51的状态字及控制字寄存器。51单片机通过写SFR来控制相应功能部件（定时器、串口、中断等）的工作方式，同时SFR也综合的、实际的反映了整个单片机基本系统内部的工作状态。例如，前面提到的PSW程序状态字寄存器，就是一个特殊功能寄存器。 ¶可位寻址的SFR位地址 ¶累加器 A 累加器A是一个最常用的专用的寄存器，大部分单操作数指令的操作数取自累加器，很多双操作数指令的一个操作数取自累加器，加、减、乘、除算术运算指令的运算结果都存放在累加器A或B寄存器中。 ¶寄存器 B 在乘、除指令中，用到B寄存器。不进行算数操作时，可作为一般寄存器使用。 ¶程序状态字寄存器PSW PSW是一个8位寄存器，它包含了程序状态信息。 ¶栈指针SP 栈指针SP是一个8位专用寄存器，它指示出堆栈顶部在内部RAM块中的位置. 51的栈向上生成，栈指针先加1，再存储，且后入先出。 先 +1 再入栈, 先弹出后 -1 系统复位后，SP初始化为 07H ，使得堆栈事实上由08H单元开始，考虑到08H～1FH单元分别属于工作寄存器区1～3，若在程序设计中要用到这些区，则最好把SP值改置为1FH或更大的值。 123456789 MOV 81H, #30H= MOV sp, #30H; 堆栈指针 sp 的位地址为 81H, 这两种表示方式等效 MOV sp, #60H; CPU执行一条A累加器进栈指令 PUSH A; 先 +1 后入栈 PUSH B; 最后 (61H) = A, (62H) = B ... POP B; 现场保护 POP A; 出栈先弹出后 -1 ¶数据指针DPTR 数据指针DPTR是一个16位的SFR，其高位字节寄存器用DPH表示，低位字节寄存器用DPL表示。DPTR既可以作为一个16位寄存器来用，也可以作为两个独立的8位寄存器DPH和DPL来用。 123MOV DPL, #10H ;立即数寻址, 给 DPRT 高八位赋值 11H, 低八位赋值 10HMOV DPH, #11H ;DPTR = 1110HMOVX A, @DPTR;寄存器间接寻址, 把外扩存储器地址为 1110H 里的数传给 A ¶特殊功能寄存器P0~P3 特殊功能寄存器P0～P3分别为I/O端口P0~P3的锁存器。即每一个8位I/O口都为RAM的一个单元（8位） 在MCS51中，I/O口和RAM统一编址，所有访问RAM的指令，都可用来访问I/O口。对于片外数据存储器和扩展的I/O口，也是统一编址的。 I/O 口统一编址: 进行 I/O 扩展时有意义 ¶串行数据缓冲器SBUF 串行数据缓冲器SBUF用于存放欲发或已接收的数据，它在SFR块中只有一个字节地址，但是物理上由两个独立的寄存器组成，一个发送一个接收。 ¶定时器/计数器 51单片机有2个16位定时/计数器T0、T1，他们各由两个独立的8位寄存器组成，分别是TH0、TL0；TH1，TL1。不能把T0、T1作为16位寄存器操作。 ¶位地址空间 MCS51中共有可寻址的位 211 个，构成了8051的位地址空间。 在RAM区，有可寻址128位，其位地址为 00~7FH 。可位寻址RAM的字节地址为 20H~2FH ； 可位寻址的SFR，共83位（其中IE为7位，IP为5位，PWS为7位，其余每个为8位）。 片内 RAM 地址为 20H~2FH 的 16 的 128 位(8 × 16 = 128) 可进行位寻址, 也可进行字节寻址. 地址为 30H~FFH 的单元为用户 RAM 区, 只能进行字节寻址, 用作存放数据及作为堆栈区使用. 只有以 “0” 或 “8” 结尾的地址才能够寻址, 例: 计算位地址位 30H 的字节地址 30H , 字节地址 = 26H ¶外部数据存储器 当内部RAM不够使用时，可以外扩数据存储器，最多 64k。 64kB = 2^16 位, 需要 8 个 I/O 口. 外接数据存储器的 写端 和 读端. 接 2 根(要读要写); 外接程序存储器. 接 1 根(只读). ¶关于地址重叠： 程序存储器与外部数据存储器地址重叠（通过指令） 片内程序存储器与片外程序存储器地址重叠（通过EA管脚） RAM的字节地址与位地址重叠（通过字节指令与位操作指令） 52的高128字节RAM地址与SFR地址重叠（通过不同的寻址方式） 52 增强型单片机与 51 单片机相比, 片内数据存储器增加了 128 B, 对应的字节地址为 80H ~ FFH . 这高 128 B 的 RAM 单元地址与特殊功能寄存器区的字节地址重合, 但它们是两个不同的物理区域. 对这两个具有相同地址区域进行访问时, 是由不同的指令寻址方式来区分的—— 对于地址为 80H ~ FFH 的 RAM 区, 只能采用间接寻址的方式访问, 对于地址为 80H ~ FFH 的特殊功能寄存器区的访问只能采用直接寻址方式. 对于低 128 B (00H ~ 7FH) 的 RAM 区, 既可以采用直接寻址方式又可以采用间接寻址方式来访问.","categories":[{"name":"Electricity","slug":"Electricity","permalink":"http://example.com/categories/Electricity/"},{"name":"硬件","slug":"Electricity/硬件","permalink":"http://example.com/categories/Electricity/%E7%A1%AC%E4%BB%B6/"}],"tags":[{"name":"专业课","slug":"专业课","permalink":"http://example.com/tags/%E4%B8%93%E4%B8%9A%E8%AF%BE/"}]},{"title":"嵌入式原理及应用(02)-MCS-51的硬件结构","date":"2022-08-26T08:37:10.000Z","path":"2022/08/26/嵌入式原理及应用-02MCS-51的硬件结构/","text":"¶MCS-51 的引脚功能 ¶电源以及时钟引脚 电源引脚 Vcc: 接 +5v 电源 电源引脚 Vss: 接数字地(GND) 时钟引脚 XTAL1: 如果采用外接晶体振荡器时，此引脚应接地。使用片内振荡器，应接外部石英晶体和微调电容。使用片外振荡器，该脚接外部时钟振荡器输出的信号。 时钟引脚 XTAL2: 片内振荡器反相放大器的输出端。使用片内振荡器，接外部石英晶体和微调电容。使用片外振荡器，悬空。 ¶控制引脚 RST/VPD(9脚): 复位信号/备用电源的输入端。RST是复位信号输入端，高电平有效。加上两个机器周期的高电平时，就可以完成复位操作。在单片机正常工作时,此脚应该为 &lt;0.5v 低电平. RST引脚的第二功能是VPD，即备用电源的输入端, 接上备用电源，系统掉电时向内部RAM供电，使其保持数据。 ALE/ PROG(30脚) ALE(address lock enable): P0 口既做地址总线(AB) 又做数据总线(DB), 当访问单片机外部存储器时，ALE (地址锁存允许)输出脉冲的负跳沿用于16位地址的低8位的锁存信号。在P0 口做DB时用 地址锁存器ALE 来保存下降沿左端的地址信息, 示意图如下: 即使不访问外部锁存器，ALE端仍有正脉冲信号输出，此频率约为时钟振荡器频率的1 / 6。但在执行某些指令时会不发出ALE信号，因而用户不能用做时钟源或定时。约为时钟振荡器频率的1 / 6, 每当执行访问外部RAM或I/O指令时会丢失一个 ALE 脉冲, 故并不是精确的1 / 6 周期. PSEN（29脚）：程序存储允许输出信号端（片外ROM选通线）。在 PSEN脚为低电平时, 选中片外程序存储器。此引脚接EPROM的OE端。 EA(31脚) 当 EA 端保持高电平时, 51单片机先访问内部程序存储器, 但当 PC(程序计数器) 值超过 0FFFH 时(8051, 8751), 将自动转向执行外部程序存储器内的程序. 当 EA 保持低电平时, 不管是否有内部程序存储器, 只访问外部程序存储器. 0000H ~ 0FFFH: 4k个存储单元, byte, 1k = byte ¶I/O 口引脚 ¶I/O 口的功能 为4个并行8位I/O口，输入输出 8 位数据。 P0口：双向8位三态I/O口，此口为地址总线（低8位）及数据总线分时复用口，由ALE信号作为地址锁存, 可驱动8个LS型TTL负载。 漏极开路的 8 位并行双向 I/O 口 当扩展外部存储器及 I/O 接口芯片时, P0 为口分时复用的低 8 位地址/数据总线. 向 P0 口输入 1 后就成为了高阻态的输入口 P0 口做通用 I/O 口使用时, 需外加上拉电阻, 此时为准双向口 P1口：8位准双向I/O口，可驱动4个LS型TTL负载, 供用户使用。 准双向 I/O 口, 具有内部上拉电阻 P2口：8位准双向I/O口，与地址总线（高8位）使用，可驱动4个LS型TTL负载。当扩展的外部存储器小于64k时，即有未用到的P2口线，可作为一般I/O口使用。 准双向 I/O 口, 具有内部上拉电阻 当访问外部存储器及 I/O 口时, P2 作为高 8 位地址总线使用, 输出高 8 位地址. 不做地址总线时, 可作为通用 I/O 口使用. P3口：8位准双向I/O口，即可作为一般I/O口使用，也可作为第二功能口使用. 控制总线, 可驱动4个LS型TTL负载。 准双向 I/O 口, 具有内部上拉电阻 P3 的第二功能要熟记 P3 口的第二功能: P0 口作为地址总线(低 8 位)及数据总线使用时, 为双向口. 作为通用的 I/O 口使用时需要加上拉电阻, 为准双向口. P1, P2, P3 口内部均有上拉电阻, 均为准双向口, 没有高阻’悬浮态’. ¶I/O 口的内部结构 每一位引脚由锁存器、输出驱动器和输入缓冲器组成。 P1口作为输出使用: 输出高电平: Q为1，Q非为0，驱动管截止，P1口引脚在上拉电阻作用下，输出高电平； 输出低电平: Q为0，Q非为1，驱动管导通，P1口引脚输出低电平； P1口作为输入使用 首先要通过内部总线写高电平1，Q非为0，使驱动管截止，这样由外部电路引起的P1口引脚的状态就能通过下面的缓冲器送到内部总线上； 如果做输入之前写低电平0，则Q非为1，驱动管导通，P1口引脚始终被拉低为低电平，外部电路无法在引脚上施加高电平1，从而无法作为双向口使用。 P1口作为输入使用前必须先写高电平 上下两个缓冲器，数据可通过锁存器、上面的缓冲器送到内部总线，也可通过引脚、下面的缓冲器送到内部总线。 ¶双向口与准双向口 注意:准双向口与双向三态口的差别，当3个准双向I/O口作输入口使用时，要向该口先写“1”。准双向I/O口无高阻的“浮空”状态。 TTL电平信号被利用的最多是因为通常数据表示采用二进制规定，+5V等价于逻辑“1”，0V等价于逻辑“0”，这被称做TTL（晶体管-晶体管逻辑电平）信号系统，这是计算机处理器控制的设备内部各部分之间通信的标准技术。 TTL电平信号对于计算机处理器控制的设备内部的数据传输是很理想的，首先计算机处理器控制的设备内部的数据传输对于电源的要求不高以及热损耗也较低，另外TTL电平信号直接与集成电路连接而不需要价格昂贵的线路驱动器以及接收器电路；再者，计算机处理器控制的设备内部的数据传输是在高速下进行的，而TTL接口的操作恰能满足这个要求。TTL型通信大多数情况下，是采用并行数据传输方式，而并行数据传输对于超过10英尺的距离就不适合了。这是由于可靠性和成本两面的原因。因为在并行接口中存在着偏相和不对称的问题，这些问题对可靠性均有影响。 TTL输出高电平&gt;2.4V，输出低电平&lt;0.4V。在室温下，一般输出高电平是3.5V，输出低电平是0.2V。最小输入高电平和低电平：输入高电平&gt;=2.0V，输入低电平&lt;=0.8V，噪声容限是0.4V。 TTL门电路是双极型集成电路，与分立元件相比，具有速度快、可靠性高和微型化等优点。 高阻态即不外接 参考资料: CSDN: LS型TTL负载 ¶I/O 口的读操作 读锁存器 读锁存器指令是从锁存器中读取数据，进行处理，并把处理后的数据重新写入锁存器中，这类指令称为读、修改、写指令。在ANL、ORL、XRL； JBC； CPL； INC、DEC； DJNZ； MOV、 CLR、 SETB等指令中，当目的操作数为某一I／O口或I／O口的某一位时，这些指令均为读、修改、写指令。 当给 I/O 口锁存器写入某一状态后，相应的口引脚是否呈现锁存器的状态，是与外电路的连接有关。 例如，用I/O口线驱动外部三极管基极时，该口线被 锁存器写入“1” 后使外部三极管导通，而三极管一旦导通后，基极电平为“0”。口锁存器与引脚状态不一致 当给一个准双向口 输出“0” 后，输出驱动器打开，管脚电位拉低为“0”，此时如将该管脚作输入脚使，将无法输入高电平。 由此可见，在设计8051系统时，对51的I/O管脚要统一规划使用，一个管脚不能既作为输入，又作为输出。换言之，一个管脚如果第一次用其为输入，一直用其作为输入管脚 读引脚 读引脚指令一般都是以I/O端口为源操作数的指令，执行读引脚指令时，打开三态门，输入口状态。例如，读P1口的输入状态时，读引脚指令为：MOV A，P1。 ¶MCS-51 的CPU MSC-51 单片机的 CPU 为8位的CPU，且内含一个1位的位处理器，可进行字节数据和位变量的处理，是由运算器和控制器组成的。 ¶运算器 ¶算数运算逻辑单元 ALU 功能强大，它不仅可对8位变量进行逻辑\"与、或异或”循环、求补和清零等基本操作，还可以进行加、减、乘、除等基本运算, ALU还具有位处理操作，如置位、清零、求补、测试。转移及逻辑“与、或”等操作。 ¶累加器 A 累加器 A 是CPU 中使用最频繁的一个8位寄存器。 是 ALU 的输入数据源之一, 也是ALU 的运算结果存放单元, 是 ALU 的主要寄存器. 累加器中的进位位 Cy (位于程序状态字特殊功能寄存器 PSW 中) 是特殊的, 因为它同时又是位处理器的累加器. CPU 中的数据大多数通过 A 传送, 大部分指令都会用到它(语言听上去不是全部指令都用上, 有一部分是不会经过 A 的数据传输指令) ¶寄存器 B 是为执行乘法和除法操作设置的，在不执行乘除法操作的一般情况下可把它当作一个 普通寄存器使用。 在乘法运算时，累加器A和寄存器B在乘法运算前存放乘数和被乘数，运算完，寄存器B存放低八位, 累加器A存放高八位。 除法运算前，累加器A和寄存器B存入被除数和除数，运算完用于存放商和余数。 ¶程序状态字寄存器 PSW (Program Status Word) Cy (PSW.7)：进位标志位。在进行加法或减法运算时，若运算结果最高位有进位或借位，则Cy自动置 “1”，否则Cy置 “0”；在进行布尔操作运算时，Cy （简称C）作为布尔处理器。 AC (PSW.6/)：辅助进位标志位。当进行加法或减法运算时，若低4位向高4位有进位或借位时，AC被置 \"1”，否则AC被置 “0”。在十进制调整指令中AC还作为十进制调整的判别位。 F0 (PSW.5)：用户标志位。用户可用软件对F0位置 “1” 或清 “0”，以决定程序的流向。 RSI、RS0 (PSW.4, PSW.3)：工作寄存器区选择位，用来选择当前工作的寄存器区。用户通过改变RS1、RS0的内容来选择当前工作寄存器区。RSI、RS0的内容与工作寄存器区的对应关系如表2-2所示。 OV (PSW.2)：溢出标志位，当运算结果溢出时，OV为 “1”，否则为 “0”。此标志位反映了运算结果是否溢出。 D1 (PSW.1)：未定义位。 P (PSW.0)：奇偶标志位。MCS-51单片机采用偶校验。当累加器A中 “1”的个数为奇数时，P置 “1\",否则P置 “0\"。此位反映累加器A中内容“1\"的奇偶性，它常常用于机间通信。在串行通信中常用奇偶校验的方法检验数据串行传输的可靠性. 串行通信（英语：Serial communication） 串口类似于一条车道，而并口就是有8个车道同一时刻能传送8位（一个字节）数据。但并不是并口快，由于8位通道之间的互相干扰。传输时速度就受到了限制。而且当传输出错时，要同时重新传8个位的数据。串口没有干扰，传输出错后重发一位就可以了，所以要比并口快。 ¶控制器 控制部件是单片机的神经中枢，以主振频率为基准(每个主振周期称为振荡周期),控制器控制CPU的时序，对指令进行译码，然后发出各种控制信号，它将各个硬件环节组织在一起。 它的功能是根据程序计数器PC的内容取指令，然后进行指令译码，并严格按照定时控制电路依据指令译码的内容产生相应的控制信号，协调各部分的工作，完成指令所规定的操作。 ¶程序计数器PC 是控制器内独立的16位计数器寄存器, 是程序存储器的地址指针. 它用来存放CPU执行的下一条指令的地址。当一条指令按照PC所指的地址从程序存储器中取出后，PC会自动加1，指向下一条指令。程序计数器PC是一个16位的寄存器，可寻址64KB的程序存储器空间。 当单片机复位时, PC 内容变为 0000H. 因而程序总是从程序存储器的0000H处开始执行。 一些指令会影响到PC的连续性，例如跳转类，中断响应等。 PC不是SFR ¶指令寄存器、指令译码器及控制逻辑电路 分别用来存放指令操作码、对指令译码、根据译码结果发出一 系列控制信号,使微控制器的各组成部件进行相应的工作，执行指令。 ¶复位电路 复位为单片机提供了初始化手段，当RST引脚保持24个时钟周期以上的高电平将引起复位。 在复位有效期间（即高电平），ALE引脚为高电平，且内部RAM不受复位的影响。 复位后的部分寄存器状态 PC=0000H PSW=00H 选择工作寄存器0区 SP=07H ¶时钟电路 ¶内部方式 晶振 1.2MHz~12MHz 电容 20pF~100pF, 典型值：30pF ¶外部方式","categories":[{"name":"Electricity","slug":"Electricity","permalink":"http://example.com/categories/Electricity/"},{"name":"硬件","slug":"Electricity/硬件","permalink":"http://example.com/categories/Electricity/%E7%A1%AC%E4%BB%B6/"}],"tags":[{"name":"专业课","slug":"专业课","permalink":"http://example.com/tags/%E4%B8%93%E4%B8%9A%E8%AF%BE/"}]},{"title":"嵌入式原理及应用(01)-绪论","date":"2022-08-25T12:02:29.000Z","path":"2022/08/25/嵌入式原理及应用-01/","text":"本文档为hit梁慧敏教授2022年秋季学期《嵌入式系统原理及应用》随堂笔记 本人上外专业课，本文档笔记均为个人理解，若有错误欢迎邮箱讨论。 ¶前言 嵌入式系统是嵌入到对象系统中的专用计算机应用系统。其本质是将计算机嵌入到一个对象体系中，以实现对象体系智能化控制的计算机系统。 嵌入式系统，其本质是将计算机嵌入到一个对象体系中，以实现对象体系智能化控制的计算机系统。 “嵌入性”、“专用性”与“计算机系统”是嵌入式系统的三个基本要素。 嵌入性：微控制器嵌入到物体中去; 专用性：一个专门用在某类对象上的系统不能用在其他对象上; 计算机系统：一个嵌入式系统就是一个小型计算机系统 ¶单片机的概念 单片机就是一块具有一台计算机属性的芯片，在一块硅片上集成了微处理器（CPU）、存储器（RAM,ROM,EPROM）和各种输入、输出接口（定时器/计数器，并行I/O口，串行口，A/D转换器以及脉冲调制器PWM等），被称为单片微型计算机，简称单片机。 单片机主要体现在其控制属性上. 计算机只能处理数字量, 模拟量的数据需要通过模数转换(A/D转换)变为数字量. 若单片机内部没有内置A/D转换功能则需要外置A/D转换芯片. 1976～1978年，美国英特尔、仙童、莫斯特克等公司相继推出8位单片机。限于当时所能达到的集成度,这些8位单片机的性能只达到中、低档水平:内存寻址范围小于4千字节，只有并行的输入输出接口,只读存储器容量小于2千字节，随机存储器容量小于128字节，指令系统是专用的并以单字节指令为主。直至目前产量最大应用最广的仍为这类单片机，其中典型产品有英特尔公司的MCS48、仙童公司的F8和莫斯特克公司的3870等。1978～1983年期间各种高性能单片机相继问世。它们的寻址范围扩大到64～128千字节,只读存储器容量达4～8千字节,随机存储器容量达128～256字节,并增加了串行输入输出接口和模数转换器。这类高性能单片机可适用于更复杂的系统，如智能终端、局部网的接口等。典型产品有英特尔公司的MCS51,美国莫托洛拉公司的6801和泽洛格公司的Z8等。1983年以后，16位单片机问世。随着集成工艺水平的提高，有可能在一块芯片上集成十几万个管子,如英特尔公司的16位单片机MCS96的集成度达12万管子／片。它有5个8位并行输入输出接口,4个全双工串行接口,8级中断处理系统,4个16位可编程序定时器／计数器。莫托洛拉公司的16位单片机8096-A6有8个通道的10位模数转换器，指令系统能处理位、字节、字和双字的操作，16位加法计算时间达1微秒,指令平均执行时间为1～2微秒。它还配备面向工业控制的高级语言(如PL/M、FORTH、C语言等),工作电压为5伏、功耗1瓦。一块16位单片机的功能已能达到一台多片机系统的水平。 ¶一些概念的辨析 单片机是微处理器（CPU）、存储器（RAM、ROM、EPROM、flash存储器）、各种输入输出接口（定时/计数器、串行口、并行I/O口等），集成在一块集成电路芯片中，从而构成完整的微型计算机。 单片机也是一种微型计算机，普通微机：主板、CPU、硬盘、I/O口（键盘、鼠标）、定时/计数器等，各部分相互分离。单片机也是微型计算机。 微处理器、微处理机和CPU它们都是中央处理器的不同称谓，微处理器芯片本身不是计算机。而微计算机、单片机它们都是一个完整的计算机系统，单片机是集成在一个芯片上的用于测控目的的单片微计算机。 广义上讲，凡是系统中嵌入了“嵌入式处理器”，如单片机、DSP、嵌入式微处理器，都称其为“嵌入式系统”。但多数人把 “嵌入”嵌入式微处理器的系统，称为“嵌入式系统”。 目前“嵌入式系统”还没有一个严格和权威的定义。目前人们所说的“嵌入式系统”，多指后者。 ¶数字信号处理器(Digital signal processor, DSP) 数字信号处理器( DSP ) 是一种专用微处理器芯片，其架构针对数字信号处理的操作需求进行了优化。DSP 是在MOS 集成电路芯片上制造的。 DSP用于数据处理应用; DSP的执行速度很快 MCU用于I/O口控制 CMOS电路具有低功耗, 高密度的优点 DSP 的目标通常是测量、过滤或压缩连续的真实模拟信号。大多数通用微处理器也可以成功地执行数字信号处理算法，但可能无法实时连续地跟上这种处理。此外，专用 DSP 通常具有更好的功率效率，因此由于功耗限制，它们更适合用于移动电话等便携式设备。 ¶现场可编程逻辑门阵列(Field Programmable Gate Array, FPGA) FPGA 由若干基本门组成, 以硬件描述语言（Verilog或VHDL）描述的逻辑电路，可以利用逻辑合成和布局、布线工具软件，编程逻辑组件可以被用来实现一些基本的逻辑门数字电路（比如与门、或门、异或门、非门）或者更复杂一些的组合逻辑功能，比如译码器等。 FPGA 的执行速度比 DSP 要更快. ¶ROM, FLASH和RAM的区别 ¶ROM (Read Only Memory)程序存储器 ROM全称Read Only Memory，顾名思义，它是一种只能读出事先所存的数据的固态半导体存储器。ROM中所存数据稳定，一旦存储数据就再也无法将之改变或者删除，断电后所存数据也不会消失。其结构简单，因而常用于存储各种固化程序和数据。 在单片机中用来存储程序数据及常量数据或变量数据，凡是c文件及h文件中所有代码、全局变量、局部变量、‘const’限定符定义的常量数据、startup.asm文件中的代码（类似ARM中的bootloader或者X86中的BIOS，一些低端的单片机是没有这个的）通通都存储在ROM中。 为了便于使用和大批量生产，进一步发展出了可编程只读存储器（PROM）、可擦除可编程只读存储器（EPROM）。EPROM需要用紫外线长时间照射才能擦除，使用很不方便。1980s又出现了电可擦除可编程只读存储器（EEPROM），它克服了EPROM的不足，但是集成度不高、价格较贵。于是又发展出了一种新型的存储单元结构同EPROM类似的快闪存储器（FLASH MEMORY）。FLASH集成度高、功耗低、体积小，又能在线快速擦除，因而获得了快速发展。 ¶FLASH 存储器 Flash 存储器（FLASH EEPROM）又称闪存，快闪。它是EEPROM的一种。它结合了ROM和RAM的长处。不仅具备电子可擦除可编辑（EEPROM）的性能，还不会断电丢失数据同时可以快速读取数据。它于EEPROM的最大区别是，FLASH按扇区（block）操作，而EEPROM按照字节操作。FLASH的电路结构较简单，同样容量占芯片面积较小，成本自然比EEPROM低，因此适合用于做程序存储器。 ¶RAM (Random Access Memory)随机访问存储器 RAM又称随机存取存储器，存储单元的内容可按照需要随机取出或存入，且存取的速度与存储单元的位置无关。这种存储器在断电时，将丢失其存储内容，所以主要用于存储短时间使用的程序。 它主要用来存储程序中用到的变量。凡是整个程序中，所用到的需要被改写的量（包括全局变量、局部变量、堆栈段等），都存储在RAM中。 ¶ROM, FLASH和RAM的区别 对于RAM, ROM以及FLASH的区别，简单地说，在计算机中，RAM 、ROM都是数据存储器。RAM 是随机存取存储器，它的特点是易挥发性，即掉电失忆。 ROM 通常指固化存储器(一次写入，反复读取)，它的特点与RAM 相反。ROM又分一次性固化、光擦除和电擦除重写两种类型。 在应用中，常规上ROM是用来存储固化程序的，RAM是用来存放数据的。由于FLASH ROM比普通的ROM读写速度快，擦写方便，一般用来存储用户程序和需要永久保存的数据。譬如说，现在家用的电子式电度表，它的内核是一款单片机，该单片机的程序就是存放在ROM里的。电度表在工作过程中，是要运算数据的，要采集电压和电流，并根据电压和电流计算出电度来。电压和电流时一个适时的数据，用户不关心，它只是用来计算电度用，计算完后该次采集的数据就用完了，然后再采集下一次，因此这些值就没必要永久存储，就把它放在RAM里边。然而计算完的电度，是需要永久保存的，单片机会定时或者在停电的瞬间将电度数存入到FLASH里。 原文: 知乎: Choris- ROM, FLASH和RAM的区别 ¶存储单位转换 名称 字符表示 说明 位 bit 一个二进制数据0或1，是1bit 机器字长 字 一个机器字长在32位系统中是4个字节, 在64位系统中是8个字节 字节 byte/B 1 byte = 8 bit一个8位的二进制数称为一个字节;存储空间的基本计量单位，如：MySQL中定义 VARCHAR(45) 即是指 45个字节；一个英文字符占一个字节(1 byte = 8 bit)；一个汉字占2个字节2 byte = 16 bit； 1 Byte = 8 Bits 1 KB = 1024 Bytes 1 MB = 1024 KB 1 GB = 1024 MB ¶各种类型数据的占用大小 一个int型是4B，也就是4个字节，一个字节8bit（位），所以就是32位 参考: 计算机各单位间转换（位，字节，进制间转换）","categories":[{"name":"Electricity","slug":"Electricity","permalink":"http://example.com/categories/Electricity/"},{"name":"硬件","slug":"Electricity/硬件","permalink":"http://example.com/categories/Electricity/%E7%A1%AC%E4%BB%B6/"}],"tags":[{"name":"专业课","slug":"专业课","permalink":"http://example.com/tags/%E4%B8%93%E4%B8%9A%E8%AF%BE/"}]},{"title":"微积分(1)-函数","date":"2022-07-25T01:51:46.000Z","path":"2022/07/25/微积分-1函数/","text":"¶函数的概念 ¶实数与数轴 实数具有两个性质： 有序性（全序性）：任意两个互异的实数 、 都可以比较大小，实数按照由小到大的顺序排列在数轴上； 完备性：任意两个有理点 、 之间都有一个有理点 , 从而它们之间有无穷多个有理点，即有理点处处稠密。因为有理数与无理数的和为无理数，所以无理点也处处稠密。实数充满整个数轴没有空隙就是实数的完备性。 复数没有有序性； 若说有理数或无理数充满整个数轴没有间隙是错误的； 所有的分数都是有理数，无限不循环小数才是无理数，而分数都可以化为有限小数或无限循环小数。 ¶数集与界 自然数集：N ，整数集：Z ，有理数集：Q ，实数集：R 区间：介于两个实数之间的集合。 邻域：设 ,称开区间 为点 的 邻域，记作 去心邻域：称集合 为 的去心 邻域， 记作 。 定义1.1 对于数集 ，若有常数 使得 则说数集 有上（下）界，并称 为数集 的一个上（下）界。 对于既有上界又有下界的数集叫做有界数集，否则为无界数集。 如果某数集上有上（下）界，那么就会有无穷个上（下）界。 公理 凡非空有上界的数集 一定有最小上界 ，称为数集 的上确界，记作 。 命题 非空有下界的数集 一定有最大下界 ，称为数集 的下确界，记作 。 是集合 的上确界等价于： ，必须满足 ，使得 对于最小下确界同理 ¶绝对值 表示 到原点的距离，绝对值的性质： 当 时， 当 时， ¶函数的概念 定义1.2 如果两个变量 和 之间有一个数值对应规律，使得变量 在其可取值的数集 内取得每一个值时，变量 就依照这个规律确定对应的值，则说 是 的函数。记作： 函数概念中有两个要素：1. 对应规律； 2. 定义域。所以说函数 与 是两个不同的函数。定义域不一样 没有说明定义域时，为天然定义域，即：使函数有意义的所有实数的集合。 正函数的值域就是反函数的定义域。 ¶几个常用的概念 ¶函数的几种性质 (1) 奇偶性 奇函数：, 偶函数： 奇函数的和仍为奇函数，偶函数的和仍为偶函数；两个奇函数的积或两个偶函数的积都是偶函数；一个奇函数和一个偶函数的积为奇函数。 (2) 周期性 设函数的定义域为 ，若有常数 ，使得当 时，必有 且： 则称 是周期函数，并称常数 是它的一个周期。 并不是所有的周期函数都有基本周期。 eg: 常值函数 ，所有的正实数都是其周期，没有最小正周期。 (3) 单调性 对于 单调函数： 严格单调函数： (4) 有界性 在定义域上有界（等同于既有上界又有下界）的函数叫做 有界函数。 ¶隐函数和参数方程表示的函数 若变量 之间的函数关系由一个含有 的方程： 给定，则说 是 的隐函数。相应的，把由自变量的算式表示出因变量的函数叫做显函数。如果能将 从隐函数中解出来，就得到它的显函数形式，但不是所有隐函数都能表示成显函数。 注意，也并不是任意一个含有 的式子就是一个隐函数，如： 就不是隐函数。 只有一个量在动，所决定的是曲线； 两个量在动，所决定的是曲面。 例题 设函数 满足关系 其中 为常数，，求函数 。 解： 由所给关系式知，若 在点 处有定义，则在点 处也有定义。由所给关系式得： 两式联立，解代数方程组得 ¶单值函数与多值函数、反函数 反函数：两个不但涉及到的自变量与因变量对换，且涉及到的运算顺序都是相反的函数。 反函数的图形关于直线 对称 单值单调的函数有反函数，其反函数也是单值单调的函数。 ¶初等函数 ¶基本初等函数 幂函数： 指数函数： 对数函数： 三角函数 … 和差化积 积化和差 三角函数无反函数，确定在某一个单调区间上有，但此时已不是原来的函数了。 ¶复合函数与初等函数 称为由函数 和 构成的复合函数， 叫做中间变量。 初等函数：由基本初等函数经过四则运算和有限次符合而来，并能用一个式子表达的函数。 双曲正弦： 双曲余弦： 双曲正切： 双曲余切： ¶极坐标 M 为平面上任意不在极点的点，极径 ：由 到 的距离；极角 ：射线从 第一次逆时针旋转到 位置所转过的角度。 ¶极坐标与直角坐标的关系","categories":[{"name":"Math","slug":"Math","permalink":"http://example.com/categories/Math/"},{"name":"微积分","slug":"Math/微积分","permalink":"http://example.com/categories/Math/%E5%BE%AE%E7%A7%AF%E5%88%86/"}],"tags":[{"name":"Math","slug":"Math","permalink":"http://example.com/tags/Math/"}]},{"title":"微积分(4)-三角函数","date":"2022-07-14T07:50:15.000Z","path":"2022/07/14/微积分-3三角函数/","text":"参考：三角恒等式 ¶和差化积、积化和差 ¶和差化积 ¶积化和差","categories":[{"name":"Math","slug":"Math","permalink":"http://example.com/categories/Math/"},{"name":"微积分","slug":"Math/微积分","permalink":"http://example.com/categories/Math/%E5%BE%AE%E7%A7%AF%E5%88%86/"}],"tags":[{"name":"Math","slug":"Math","permalink":"http://example.com/tags/Math/"}]},{"title":"微积分(3)-解微分方程","date":"2022-07-13T13:14:27.000Z","path":"2022/07/13/微积分-2解微分方程/","text":"¶常系数齐次线性微分方程 微分方程形式： y的解的形如： 带入上式，解得： 即为上述微分方程的特征方程，其根为特征根。 n个互异的特征根 ,对应着， 为一个基本解组; 若有复特征根，则必成对出现：, 若有重根 若 为重根，对应着： ¶常系数非齐次线性微分方程 微分方程： 微分方程的特征方程: ¶解微分方程的通解 微分方程的解存在且有唯一性。 ¶解微分方程的特解 微分方程等号右边的非齐次项形如： 、是多项式，是它们的次数的最大值，若是特征方程的重特征根，则非齐次方程的特解形如： 、是的次待定多项式，带入原微分方程中可求解、的系数。最终是通解为：","categories":[{"name":"Math","slug":"Math","permalink":"http://example.com/categories/Math/"},{"name":"微积分","slug":"Math/微积分","permalink":"http://example.com/categories/Math/%E5%BE%AE%E7%A7%AF%E5%88%86/"}],"tags":[{"name":"Math","slug":"Math","permalink":"http://example.com/tags/Math/"}]},{"title":"微积分(2)-二元积分","date":"2022-06-22T08:11:02.000Z","path":"2022/06/22/微积分-1二元积分/","text":"¶积分 ¶格林公式 格林定理给出了沿封闭曲线 C 的线积分与以 C 为边界的平面区域 D 上的双重积分的联系。格林定理是斯托克斯定理的二维特例。 设闭区域 D 由分段光滑的简单曲线 L 围成，函数 P(x,y)及 Q(x,y)在 D 上有一阶连续偏导数，则有： 其中闭环曲线L逆时针旋转时取正。它给出了沿着闭曲线C的曲线积分与C所包围的区域D上的二重积分之间的关系。另见格林恒等式。格林公式还可以用来计算平面图形的面积。 ¶斯托克斯定理 ¶散度 散度的物理意义表示流体微团在在运动过程中体积相对变化率的极限。 将各速度分量在其分量方向上的方向导数和称为速度矢量的散度 即： ¶旋度 ¶斯托克斯定理 ¶曲线积分 ¶第一类曲线积分 是对一段曲线（弧）的积分。积分微元为弧微分，被积函数由于在弧线上取值，因此是二元函数.积分值记为. 其中被积函数在上取值。 弧上的点满足的方程可以由两种形式给出，一种是,另一种则是参数方程的形式 对于第一种形式，被积函数可以写成只和有关的一元函数，即，弧微分可以写成, 则曲线积分化为一重积分. 对于第二种形式，被积函数可以写成只和有关的一元函数，即 ，弧微分可以写成 这就是第一类曲线积分，可用于求解不均匀曲线段的质量，被积函数即为线质量密度。 ¶第二类曲线积分 ¶解微分方程 ¶可分离变量类型 ¶齐次方程 等式左边为导数，右边为的函数，这也是很特殊的形式。 令，则。 由乘积求导法则，有。 由即可得到 ¶一阶常微分方程","categories":[{"name":"Math","slug":"Math","permalink":"http://example.com/categories/Math/"},{"name":"微积分","slug":"Math/微积分","permalink":"http://example.com/categories/Math/%E5%BE%AE%E7%A7%AF%E5%88%86/"}],"tags":[{"name":"Math","slug":"Math","permalink":"http://example.com/tags/Math/"}]}]